
Scrum és XP a frontvonalról
Hogyan használjuk a Scrum-ot

Írta:
Henrik Kniberg
Magyar fordítás:
Dezso Zoltan

  Acknowledgements
  ----------------
  The first draft of this paper took only one weekend to type, but it sure was
  an intensive weekend! 150% focus factor :o)
  Thanks to my wife Sophia and kids Dave and Jenny for putting up with
  my asocialness that weekend, and to Sophia’s parents Eva and Jörgen for
  coming over to help take care of the family.
  Thanks also to my colleagues at Crisp in Stockholm and people on the
  scrumdevelopment yahoo group for proofreading and helping me improve
  the paper.
  And, finally, thanks to all my readers who have provided a constant
  stream of useful feedback. I’m particularly glad to hear that this paper has
  sparked so many of you to give agile software development a shot!

----------------------------------------------------------------------------------------------------

  Contents
  ========
  FOREWORD BY JEFF SUTHERLAND
  FOREWORD BY MIKE COHN
  INTRO
    Disclaimer
    Why I wrote this
    But what is Scrum?
  HOW WE DO PRODUCT BACKLOGS
    Additional story fields
    How we keep the product backlog at a business level
  HOW WE PREPARE FOR SPRINT PLANNING
  HOW WE DO SPRINT PLANNING
    Why the product owner has to attend
    Why quality is not negotiable
    Sprint planning meetings that drag on and on...
    Sprint planning meeting agenda
    Defining the sprint length
    Defining the sprint goal
    Deciding which stories to include in the sprint
    How can product owner affect which stories make it to the sprint?
    How does the team decide which stories to include in the sprint?
    Why we use index cards
    Definition of “done”
    Time estimating using planning poker
    Clarifying stories
    Breaking down stories into smaller stories
    Breaking down stories into tasks
    Defining time and place for the daily scrum
    Where to draw the line
    Tech stories
    Bug tracking system vs product backlog
    Sprint planning meeting is finally over!
  HOW WE COMMUNICATE SPRINTS

----------------------------------------------------------------------------------------------------

  HOW WE DO SPRINT BACKLOGS
    Sprint backlog format
    How the taskboard works
    Example 1 – after the first daily scrum
    Example 2 – after a few more days
    How the burndown chart works
    Taskboard warning signs
    Hey, what about traceability?!
    Estimating days vs. hours
  HOW WE ARRANGE THE TEAM ROOM
    The Design Corner
    Seat the team together!
    Keep the product owner at bay
    Keep the managers and coaches at bay
  HOW WE DO DAILY SCRUMS
    How we update the taskboard
    Dealing with latecomers
    Dealing with “I don’t know what to do today”
  HOW WE DO SPRINT DEMOS
    Why we insist that all sprints end with a demo
    Checklist for sprint demos
    Dealing with “undemonstratable” stuff
  HOW WE DO SPRINT RETROSPECTIVES
    Why we insist that all teams do retrospectives
    How we organize retrospectives
    Spreading lessons learned between teams
    To change or not to change
    Examples of things that may come up during retrospectives
  SLACK TIME BETWEEN SPRINTS

----------------------------------------------------------------------------------------------------

  HOW WE DO RELEASE PLANNING AND FIXED PRICE CONTRACTS
    Define your acceptance thresholds
    Time estimate the most important items
    Estimate velocity
    Put it together into a release plan
    Adapting the release plan
  HOW WE COMBINE SCRUM WITH XP
    Pair programming
    Test-driven development (TDD)
    Incremental design
    Continuous integration
    Collective code ownership
    Informative workspace
    Coding standard
    Sustainable pace / energized work
  HOW WE DO TESTING
    You probably can’t get rid of the acceptance test phase
    Minimize the acceptance test phase
    Increase quality by putting testers in the Scrum team
    Increase quality by doing less per sprint
    Should acceptance testing be part of the sprint?
    Sprint cycles vs acceptance test cycles
    Don’t outrun the slowest link in your chain
    Back to reality
  HOW WE HANDLE MULTIPLE SCRUM TEAMS
    How many teams to create
    Synchronized sprints – or not?
    Why we introduced a “team lead” role
    How we allocate people to teams
    Specialized teams – or not?
    Rearrange teams between sprints - or not?
    Part-time team members
    How we do Scrum-of-Scrums
    Interleaving the daily scrums
    Firefighting teams
    Splitting the product backlog – or not?
    Code branching
    Multi-team retrospectives

----------------------------------------------------------------------------------------------------

  HOW WE HANDLE GEOGRAPHICALLY DISTRIBUTED
  TEAMS
    Offshoring
    Team members working from home
  SCRUM MASTER CHECKLIST
    Beginning of sprint
    Every day
    End of sprint
  PARTING WORDS
  RECOMMENDED READING
  ABOUT THE AUTHOR

Előszó - Jeff Sutherland
===========================
Egy csapatnak tudnia kell a Scrum alapjait. Hogyan készítsünk és becsüljünk Product Backlog-ot?
Hogyan csináljunk belőle Sprint Backlogot? Hogyan használjuk a Burndown Chart-ot és hogyan számítsuk
a csapat sebességét? Henrik könyve tartalmazza az alapvető gyakorlatokat, amik segítségével egy
Scrum-ot próbálgató csapatból egy Scrum-ot teljes mértékben kihasználó csapat válik.

A megfelelő Scrum gyakorlat az utóbbi időben egyre fontosabbá válik olyan csapatok számára, akik
befektetésben reménykednek. Agile trénerként egy befektetői csoportot segítek, akiknek célkitűzése,
hogy csak a befektetésre érdemes, a Scrum-ot jól használó cégekbe fektetnek. A csoport Senior
Partner-e minden jelölttől megkérdezi, hogy ismerik-e a csapataik sebességét (velocity). Jelenleg a
legtöbbjük nem vagy csak nehezen tud válaszolni. A jövőben a befektetésekhez elengedhetetlen lesz,
hogy a csapatok ismerjék a fejlesztési sebességeiket.

Hogy ez miért olyan fontos? Ha a csapatok nem ismerik a sebességüket, akkor a Product Owner nem tud
előre tervezni és kivitelezhető kiadási dátumokat adni. Ha pedig nincs megbízható kiadási dátum,
akkor a cég könnyen tönkre mehet, mivel a befektetők elvesztik a pénzüket.

Ez egy olyan probléma, ami minden vállalkozást - kicsit és nagyot, régit és újat, befektetőkkel
rendelkezpt és nem rendelkezőt - egyaránt érint. Nemrég a Google Scrum használatáról tartott londoni
beszéd során megkérdeztem a hallgatóságot (135 főt), hogy hányan használnak Scrum-ot és 30-an
felelték, hogy igen, ők Scrum-ot használnak. Ezután megkérdeztem, hogy hányan felelnek meg a Nokia
iteratív fejlesztési szabványának. Az iteratív fejlesztés az Agile Manifesztó egyik alappillére -
használható szoftvert kiadni a kezdetektől és gyakran. A Nokia több száz fejlesztői csapat több
évnyi visszajelzése alapján megállapított néhány alapkövetelményt az iteratív fejlesztéshez:
* Minden iteráció legfeljebb hat hetes rögzített időtartammal rendelkezik.
* Az iteráció végén a kód minőségteszten esett át és helyesen működik.

A 30 főből, akik azt mondták, hogy Scrum-ot használnak, csak 15 állította, hogy megfelelnek a Nokia
iteratív fejlesztési követelményeinek. Ezután azt kérdeztem meg, hogy megfelelnek-e a Nokia Scrum
követelményeinek:
* A Scrum csapatban van egy kirendelt Product Owner és a csapat tudja, hogy ki az
* A Product Owner rendelkezik Product Backlog-gal, amiben a csapat becslései is szerepelnek.
* A csapat rendelkezik Burndown Chart-tal és ismeri a sebességét.
* A csapaton kívüli személyek nem zavarják meg a csapatot egy Sprint közben.

A 30 Scrum-ot használó személy közül mindössze 3 felelt meg a Nokia Scrum tesztjének. Ezek azok a
csapatok, akikbe a befektetői ismerőseim  a jövőben be fognak fektetni.

Henrik könyvének igazi értéke, hogy ha az általa ismertetett gyakorlatokat követi, használ Product
Backlog-ot, becsüli a Backlog elemeket, rendelkezik Burndown Chart-tal és ismeri a sebességét és úgy
általában olajozottan fog működni a Scrum Önnek. Meg fog felelni a Nokia követelményeinek és
méltán reménykedhet külső befektetésben. Amennyiben cége egy startup, akár tőkét kaphat egy
befeketetői csoporttól. Ön lehet a jövő sikeres szoftverfejlesztője és a következő
generáció sikertermékének szülőatyja.

Jeff Sutherland,
Ph.D., a Scrum társszerzője

----------------------------------------------------------------------------------------------------

Előszó - Mike Cohn
=====================
A Scrum is és az Extreme Programming (XP) azt várja el a csapatoktól, hogy egy iteráció végére
elkészítsenek egy kézzel fogható, működő terméket. Ezek az iterációk szándékosan rövidek és
rögzített hosszal rendelkeznek. Ez a rövid idő alatt működő kód elkészítésére való koncentráció azt
jelenti, hogy egy Scrum vagy XP csapatban nincs idő elmélkedni. Nem lényeges hogy a legszebb UML
modellt készítsük el, a legtökéletesebb követelményelemzést írjuk meg, vagy hogy minden lehetséges
jövőbeni módosításra kész kódot írjunk. Ehelyett egy Scrum vagy XP csapatban a hangsúly azon van,
hogy a termék elkészüljön. Ezek a csapatok elfogadják, hogy előfordul, hogy hibáznak majd, de azt is
felismerik, hogy a hibák feltárásának legjobb módja hogy az ember a elméleti eszmefuttatások helyet
felgyűri az ingujjat és nekiáll ténylegesen elkészíteni a szoftvert.

Pont ez az elméleti helyett a tevékenység hangsúlyozása az, ami megkülönbözteti ezt a könyvet.
Hogy Henrik is érti ezt, az teljesen világos már a kezdetektől. Nem ír regényeket arról, hogy mi is
a Scrum (helyette az érdeklődő számára ajánl néhány weboldalt). Inkább a közepébe vág és
elmagyarázza, hogy hogyan használja a csapata a Product Backlogot. Ebből a kezdőpontból bontja ki
aztán a többi, jól működő agilis projekthez elengedhetetlen elemet. Nincsenek elmélkedések.
Nincsenek hivatkozások. Nincsenek lábjegyzetek. És nincs is rájuk szükség: Henrik könyve nem egy
filozófiai eszmefuttatás arról, hogy mi is az a Scrum, vagy hogy miért is próbáljon ki ezt vagy azt.
Ehelyett egy jól működő Scrum csapat működésébe kapunk betekintést.

Ezért kapta a könyv találóan a "Hogyan használjuk a Scrum-ot" alcímet. Lehet, hogy Ön nem így
használja a Scrum-ot, de Henrik csapata igen. Persze megfordulhat a fejében, hogy miért jó az, ha
tudja, hogy egy másik csapat hogyan használja a Scrum-ot. A válasz az, hogy egy Scrum-ot használó
(és főképp egy hatékonyan használó) csapat történeteiből magunk is tanulhatunk. Nincs és nem is lesz
egy "Scrum Előírások" lista, mert a csapatok és projektek kontextusa sokkal fontosabb minden más
megfontolásnál. Előírások helyett a gyakorlatok mellett arra is szükség van, hogy ismerjük azt a
kontextust, amelyben sikeresen használhatóak. Ha elég történetet olvas sikeres csapatokról és azok
gyakorlatairól, készen lesz bármilyen akadály elhárítására, ami a Scrum és XP használata során az
útjába akad.

Henrik rengeteg jótanáccsal szolgál majd és megadja a szükséges kontextust, hogy Ön még sikeresebben
használhassa a Scrum-ot és XP-t a saját projektei frontvonalain.


Mike Cohn
Az "Agilis Becslés és Tervezés" és "Tervezés és Felhasználói Történetek a Gyakorlatban" című könyvek
szerzője.

----------------------------------------------------------------------------------------------------

Előszó – Hé, a scrum működött!
=================================
A Scrum működött. Legalábbis nekünk (ami alatt a jelenlegi
stockholmi megbízót értem, akit nem fogok megnevezni). Remélem, hogy Önnek is működni fog.
Talán ezt az írást is hasznos iránymutatónak fogja találni.

Ez az első alkalom, hogy egy fejlesztői metodológia (elnézést Ken, keretrendszer) elsőre
működött. Csont nélkül. Mindannyian elégedettek vagyunk vele – fejlesztők, teszterek,
menedzserek. Átsegített néhány nehéz helyzeten és közben segített megőriznünk a lendületünk és
koncentrációnk a kemény piaci viszonyok és sorozatos leépítések között is.

Nem szabadna azt mondanom, hogy ez az eredmény meglepett, de mégis ezt kell mondanom. Néhány
könyv elolvasása után a Scrum jónak tűnt, de majdnem túl jónak is, hogy igaz legyen (ismerjük a
mondást “ha valami túl jónak tűnik, hogy igaz legyen…”). Érhető módon szkeptikus voltam.
Aztán egy évnyi Scrum után meglehetősen elégedett voltam (és a csapat többi tagja is elégedett
volt), olyannyira, hogy ezentúl hacsak nincs egy jó érv ellene, alapértelmezésben minden új
projektben Scrum-ot fogok használni.

----------------------------------------------------------------------------------------------------

1 Bevezetés
===========
Hamarosan bevezetésre kerül a Scrum a vállalatában. Esetleg már néhány hónapja
Scrum-ot használ. Az alapokat ismeri, a könyveket kiolvasta, az is elképzelhető, hogy Scrum
Master minősítést szerzett. Gratulálok!

És mégis valahol ott bújkál egy kis zavarodottság.

Ken Schwaber szavaival élve, a Scrum nem egy metodológia, hanem egy keretrendszer. Ez abban
nyilvánul meg, hogy a Scrum nem fogja megmondani, hogy milyen helyzetben pontosan mit is
tegyen. A fenébe!

A jó hír az, hogy én messzemenő részletességgel el fogom mondani, hogy én hogyan használom a
Scrum-ot. A rossz hír az, hogy ez csak azt fogja elmondani, hogy én hogyan használom a
Scrum-ot. Ami nem jelenti azt, hogy Önnek is így kell használnia. Ami azt illeti, én magam is
elképzelhető, hogy egy más szituációban másképp használnám.

A Scrum erőssége és egyben a gyengesége is hogy megköveteli, hogy mindig az adott helyzethez
igazítsák.

A Scrum-hoz való hozzáállásom jelenleg egy évnyi kísérletezés eredménye egy nagyjából 40 fős
fejlesztői csapattal. A cég meglehetősen nehéz helyzetben volt, rengeteg túlórával, óriási
minőségi problémákkal, állandó tűzoltással, kitolt határidőkkel, stb… Döntés született a Scrum
bevezetéséről, de ez a gyakorlatban már nem valósult meg teljesen: ez az én feladatom lett. A
fejlesztői csapat nagy részének a “Scrum” csak egy fura “buzzword” volt, amit néha hallani
lehet a folyosókon, ám ami a napi gyakorlatban nem jelenik meg.

Egy év alatt, bevezettük a Scrum-ot a cég teljes hierarchiájában, kipróbáltunk különböző csapat
méreteket (3-12 fő), különböző sprint hosszokat (2-6 hét), különböző “kész” definíciókat,
különböző backlog formátumokat (Excel, Jira, papír kártya), különböző teszt stratégiákat,
különböző demo módokat, különböző csapat-szinkronizációs módokat, stb…Kísérleteztünk XP
módszerekkel – különböző folyamatos integrációs módok, pár-programozás, teszt-alapú
programozás, stb és ezek integrációja a Scrum-mal.

Ez egy állandó tanulási folyamat, szóval a történet persze itt nem ér véget. Meggyőződésem,
hogy a cég továbbra is fejlődni fog (ha betartják a sprint visszatekintéseket (retrospective))
és új felfedezéseket fognak tenni arra vonatkozóan, hogy az ő helyzetükben mi a legjobb módszer a
Scrum használatára.

Figyelem
========
Ez az írás nem “Az Egy Helyes Mód” a Scrum használatára, hanem csak egy mód a sok
lehetséges közül, ami egy évnyi folyamatos finomhangolás eredménye. Az is elképzelhető, hogy
teljesen rossz úton járunk.

Az írás teljes egészében a személyes véleményemet tartalmazza és nem feltétlenül tükrözi a
Crisp vagy bármely kliensem hivatalos álláspontját. Éppen ezért szándékosan nem fogok konkrét
személyeket vagy termékekre hivatkozni.

Miért írtam ezt a cikket
========================
Kezdetben, amikor a Scrum-ot próbáltam megérteni, elolvastam a
Scrum-ról szóló könyveket, átböngésztem az összes internetes cikket és fórumot, letettem Ken
Schwaber vizsgáját, elárasztottam őt kérdésekkel és rengeteget beszéltem a munkatársakkal a
témáról. Mindeközben az egyik leghasznosabb információforrásomnak a valós történetek
bizonyultak. Ezek a “háborús történetek” végén az Alapelvekből és Gyakorlat-okból… nos… “De
Valójában Hogyan Használod” lesz. Abban is segítségemre voltak, hogy felismerjem (és néha el is
kerüljem) a tipikus Scrum kezdő hibákat.

Ez tehát az én lehetőségem, hogy valamit visszaadja. Ez az én történetem a frontról.

Remélem a cikk apropóján majd néhányuk hasznos visszajelzésekkel szolgál. Örömmel várom hogy
mások hogyan gondolkodnak a hasonló szituációkról.

De mi is ez a Scrum?
====================
Hupsz, elnézést. Teljesen új a Scrum-ban vagy XP-ben? Ebben az esetben az
alábbi néhány linket ajánlom:
* http://agilemanifesto.org/
* http://www.mountaingoatsoftware.com/scrum
* http://www.xprogramming.com/xpmag/whatisxp.htm

A türelmetlenek nyugodtan olvassanak tovább. A zsargon nagy részét meg fogom magyarázni ahogy
haladunk, szóval teljesen kezdőként is érdekesnek találhatja ezt az írást.

----------------------------------------------------------------------------------------------------

2 Hogyan használjuk a Product Backlogot
=======================================
A Product Backlog a Scrum motorja. Minden itt kezdődik. A Product Backlog egy prioritás alapján rendezett követelmény-,
sztori-, feature- vagy akármi- lista. Olyan akármik, amit a kliens szeretne, a kliens
nyelvezetével leírva.

Mi ezeket Sztori-nak hívjuk, vagy néha egyszerűen csak Backlog Bejegyzés-nek.

A sztorijaink a következő adatokkal rendelkeznek:
* ID – egy egyedi azonosító, jobbára csak egy automatikusan léptetett szám.
Ez azért szükséges, hogy ne veszítsük el véletlenül a sztorikat, amikor átnevezzük őket.
* Név – rövid, kifejező sztori név. Például “A saját tranzakció-történet
megjelenítése” Elég világos kell, legyen, hogy a fejlesztők és a termék-tulajdonos nagyjából
értsék miről van szó és hogy elkülönüljön a többi sztoritól. Általában 2-10 szó.
* Fontosság – a termék-tulajdonos által eldöntött fontosság értéke. Például 10, vagy 150. Minél nagyobb a
szám, annál fontosabb.
  o Amikor csak lehet, próbálom kerülni a "prioritás" kifejezést, mivel tipikusan 1 a legmagasabb
  prioritás, ami akkor tud gondot okozni, amikor egy _még_ fontosabb feladat érkezik. Milyen
  prioritást adjunk annak? 0-t? -1-t?
* Kezdeti becslés - a sztori más feladatokhoz viszonyított elvégzendő munkamennyiségének becslése.
Egysége a sztori pont, ami nagyjából egy ideális ember-napnak felel meg.
  o Kérdezze meg a csapatot, hogy "ha a sztorihoz szükséges ideális számú (se túl kevés, se
  túl sok, általában 2) emberrel bezárkóznak egy étellel jól ellátott szobába, ahol minden külső
  zavaró tényezőtől mentesen dolgozhatnak, hány nap múlva tudnak előállni a kész, bemutatható,
  tesztelt, kiadható implementációval?". Ha a válasz az, hogy "hárman bezárva egy szobába 4 nap",
  akkor a kezdeti becslés 12.
  o Nem az a lényeg, hogy az abszolút becslések helyesek legyenek (vagyis hogy egy 2 pontos sztori
    valóban 2 napot vegyen igénybe), hanem hogy a relatív becslések helyesek legyenek (azaz hogy
    egy 2 pontos sztori nagyjából fele annyi időt vegyen igénybe, mint egy 4 pontos)
* Hogyan demonstrálható - egy áttekintő leírás arról, hogy ezt a sztorit hogyan kell bemutatni a
  sprint demo-ban. Ez igazából egy leegyszerűsített teszt előírás. "Ezeket a lépéseket végrehajtva,
  ez kell legyen az eredmény".
  o Ha TDD-t (teszt-vezérelt fejlesztés) használ, ez a leírás szolgálhat az elfogadási teszt
  alapjául egyfajta pszeudo-kódként.
* Megjegyzések - minden más információ, pontosítások, más forrásokra való hivatkozás. Jó, ha minél
  rövidebb

<figure 1>

Kipróbáltunk más adatokat is, de végül a fenti hat mező volt, amit valójában mindig használtunk.

Általában egy megosztott Excel táblázatban tároljuk a backlog bejegyzéseket. Hivatalosan a Termék
Tulajdonos felelős a dokumentumért, de persze nem akarjuk a többi felhasználót kizárni. Sok esetben
egy fejlesztő hasznos pontosításokat adhat hozzá, vagy esetleg megváltoztathat egy becslést.

Hasonló okokból ezt a dokumentumot nem tároljuk verziókövető rendszerben, hanem egy hálózati
meghajtóra tesszük. Ez bizonyult a legegyszerűbb módszernek arra, hogy zárolások vagy kofliktusok
nélkül több felhasználónak egyidőben is hozzáférést biztosítsunk.

Minden más dokumentumot azonban verziókövető rendszerben tárolunk.

További sztori mezők
====================
Néha további mezőket is használunk a backlogban, többnyire hogy megkönnyítsük a Product Owner dolgát
amikor a sztorik fontosságát határozza meg.
* Kategória – a sztori körülbelüli fajtája, például "optimalizáció" vagy "backend". Ezt használva a
  Product Owner könnyen kiválaszthatja az összes "optimalizáció"-t és például alacsony priorítást
  állíthat be.
* Komponens - általában jelölőnégyzetként jelenik meg az Excel dokumentumban, például "adatbázis,
  szerver, kliens". A Product Owner ezek segítségével könnyen azonosíthatja a komponenseket, amelyek
  az implementációban szerepet játszanak. Ez akkor lehet hasznos, amikor több Scrum csapat van
  (például egy a "backend"-hez, egy a klienshez), mivel leegyszerűsíti a sztori választást az egyes
  csapatokban.
* Megrendelő - a Product Owner dokumentálhatja, hogy melyik külső- vagy belső megbízó kérte a sztori
  implementálását, hogy később könnyen visszajelezhessen ennek a megrendelőnek.
* Bugkövető ID - amennyiben külön bugkövető rendszert használ (ahogy mi is Jira-t használunk), nagy
  segítséget jelent, ha közvetlenül összekapcsolhatjuk a sztorit a hozzá tartozó hibabejelentésekkel.

Hogyan használjuk a Termék Backlogot az üzleti szinten
------------------------------------------------------
Ha a Product Owner technikai beállítottságú, előfordulhat, hogy olyan sztorik jelennek meg, mint
például "Az Events táblához indexek hozzáadása". De igazából miért van erre szüksége? A valódi ok
valószínűleg valami olyasmi, hogy "az adminisztrációs felületen a keresések gyorsítása".

Az is elképzelhető, hogy tulajdonképpen a keresések nem az indexek hiánya miatt voltak lassúak,
hanem valami teljesen más ok miatt. Általában a fejlesztő csapat sokkal jobban képes meghatározni és
megoldani a problémát, ezért a Product Owner inkább az üzleti oldalra fókuszáljon. Amikor ilyen
technikai beállítottságú sztorikat találok, a Product Owner-től addig kérdezem, hogy "de miért" amíg
meg nem találjuk a mögöttes valódi indokot. Ekkor átfogalmazhatjuk a sztorit ezt az indokot
használva ("az adminisztrációs felületen keresés felgyorsítása"). Az eredeti technikai jellegű
megfogalmazást pedig egy megjegyzésként tartjuk meg ("Indexek hozzáadása az events táblához talán jó
megoldás").

3 Hogyan készülünk fel a sprint planning meetingre
==================================
OK, a sprint planning napja egyre közeleg. Egy dolog, amivel lépten-nyomon találkozunk:

Tanulság: A Sprint Planning Meeting előtt mindenképpen tegyük rendbe a Product Backlogot.

Hogy mindez mit jelent? Hogy minden sztori legyen teljesen definiálva? Hogy minden becslés legyen
pontos? Hogy minden prioritás legyen lefixálva? Nem, nem és nem! Mindössze a következőket jelenti:
* A Product Backlog létezik! (képzelje csak el)
* Egy Product Backlog és egy Product Owner van (minden termékhez természetesen).
* Minden fontos elemhez hozzá van rendelve egy egyedi fontossági érték.
  o Ami azt illeti, nem probléma, ha a nem fontos elemekhez ugyanazt az értéket rendeli, mivel nagy
  valószínűséggel azok úgysem fognak előkerülni a Sprint Planning Meeting során.
  o Minden sztori, amiről a Product Owner úgy véli, hogy valós esélye van, hogy bekerüljön a
  következő Sprint-be, egyedi értékkel rendelkezzen.
  o A fontossági érték mindössze arra szolgál, hogy az elemeket fontossági sorrendbe állítsuk. Azaz,
  ha az A Sztori fontossága 20 és B Sztori fontossága 100, ez csak annyit jelent, hogy B fontosabb,
  mint A, nem azt, hogy B ötször olyan fontos, mint A. Ha B fontossága 21 lenne, az is pontosan
  ugyanezt jelentené.
  o Hasznos lehet a fontossági értékek között egy kevés hézagot hagyni, ha esetleg egy C jelenik
  meg, ami fontosabb, mint A, de kevésbé fontos, mint B. Persze használhatnánk 20,5-t is C-re, de az
  ilyen értékek elég hamar kicsúsznak az irányítás alól, úgyhogy jobb hézagokat hagyni.
* A Product Owner érti az összes sztorit
  (általában ő írja a sztorikat, de néha mások is hozzáadnak kéréseket, amiket a Product Owner-nek
   kell fontossági sorrendbe állítani). Az nem szükséges, hogy pontosan tudja, hogy hogyan lesz
  implementálva, de legalább azt értenie kell, hogy miért van a sztori a listán.

Megjegyzés: Más személyek is adhatnak sztorikat a Product Backlog-hoz, de csak és kizárólag a
Product Owner rendelhet fontossági értékeket a sztorikhoz. Hasonlóan, csak és kizárólag a csapat
adhat meg időbecsléseket.

További módszerek, amiket kipróbáltunk vagy fontolóba vettünk:
* Jira-t használni a Product Backlog tárolásához. Ezt a legtöbb Product Owner nehézkesnek tartotta,
  mivel túl sok klikkelést igényelt. Az Excel lapot könnyen tudják szerkeszteni. Könnyű színkódokat
  hozzáadni, cellákat átrendezni, új oszlopokat hozzáadni, megjegyzéseket hozzáadni, importálni és
  exportálni, stb...
* Agilis fejlesztőeszközök, mint például VersionOne, ScrumWorks, XPlanner, stb... Még nem jutottunk
  el oda, hogy ezeket messzemenően teszteljük, de előbb-utóbb ki fogjuk őket próbálni.

4 Hogyan tervezzük a Sprinteket
===========================
A Sprint Planning egy nagyon fontos meeting, talán a legfontosabb dolog a Scrum-ban (legalábbis 
véleményem szerint) Egy rosszul végrehajtott Sprint Planning Meeting hatással lehet a teljes
Sprint-re.

A Sprint Planning Meeting célja, hogy a csapat számára elég információval szolgáljon ahhoz, hogy
zavartalanul dolgozhassanak egy pár hétig illetve hogy elég biztonságot adjon a Product Owner-nek,
hogy ezt engedje is.

Na jó, ez elég általános volt. Konkrétan a következő dolgokról születik döntés:
* A Sprint célja
* A csapat tagjainak listája (és a rendelkezésreállásuk szintje, ha nem 100%)
* Egy Sprint Backlog ( = a Sprint alatt elvégzendő sztorik listája)
* A Sprint demonstráció dátuma
* A Napi Scrum Meeting helye és időpontja

Miért kell a Product Ownernek jelen lennie
------------------------------------------
Néhány esetben a Product Owner nem szeretne hosszú órákat vesztegetni a csapattal a Sprint Planning
Meetingen. "Srácok, én már leírtam, mit akarok. Nincs időm részt venni a meetingen". Ez egy elég
súlyos probléma.

Az egész csapat és a Product Owner azért kell, hogy jelen legyen a meetingen, mert minden sztoriban
három egymástól erősen függő változó rejtőzik.

<figure>

A kiterjedést és a fontosságot a Product Owner határozza meg. A becslést a csapat. A Sprint Planning
során a szemtől-szembeni megbeszéléssel folyamatosan ezeket a változókat finomhangoljuk.

Normális esetben a Product Owner a sprint céljának összefoglalásával és a legfontosabb sztorik
listájával nyitja a meetinget. Ezután a csapat a legfontosabbal kezdve végigmegy sztorik listáján és
megbecsüli a szükséges időket. A becslések közben azonban lényeges kérdések merülnek fel a sztori
kiterjedését illetően - "ez a 'felhasználó törlése' magában foglalja azt, hogy megszakítjuk a
felhasználó összes várakozó tranzakcióját?" Néhány esetben a válaszok meg is lephetik a csapatot és
jelentősen befolyásolhatja a becsléseket.

Egyes esetekben a sztorira adott becslés eltérhet a Product Owner elképzeléseitől. Ennek hatására
megváltoztathatja a sztori fontosságát, vagy esetleg a sztori kiterjedését, ami aztán újabb becslést
igényel a csapattól.

Ez a közvetlen együttműködés alapvető fontosságú a Scrum-ban és minden agilis fejlesztési
módszertanban.

Mi történjen, ha a Product Owner továbbra sem szeretné az idejét a Sprint Planning Meetingen
tölteni? Általában a következő taktikák egyikét szoktam alkalmazni ebben a sorrendben:
* Elmagyarázom a Product Owner-nek, hogy miért elengedhetetlen a jelenléte annak reményében, hogy
  megváltoztatja a véleményét.
* Megkérem a csapatot, hogy egy önkéntest jelöljön ki a Product Owner közvetítőjeként. A Product
  Owner-nek a következőt mondom: "Mivel nem tudsz jelen lenni a meetingen, Jeff fog téged
  képviselni és fel lesz hatalmazva hogy megváltoztassa a prioritásokat és a sztorik kiterjedését.
  Amennyire csak lehet próbálj megegyezni vele még a meeting előtt. Ha nem értesz egyet azzal, hogy
  Jeff képviseljen téged, akkor jelölj ki valaki mást, aki a meeting teljes ideje alatt jelen tud
  lenni."
* Megpróbálom meggyőzni a vezetést, hogy rendeljenek ki egy új Product Owner-t.
* Elhalasztom a sprintet amíg a Product Owner nem talál elég időt hogy jelen legyen és ezalatt nem
  kötelezem el magam semmilyen kiadás mellett. A csapatot hagyom azokon a feladatokon dolgozni, amit
  épp a legfontosabbnak gondolnak.

Miért nem engedünk a minőségből
-------------------------------
A fenti háromszögben szándékosan nem említettem egy negyedik változót: a minőséget.

Kétféle minőséget szoktam megkülönböztetni: belső- és külső minőséget.
* Külső minőségnek hívom a felhasználók által látható minőséget. A lassú vagy nem intuitív
  felhasználói interfész jó példája a rossz külső minőségnek.
* Belső minőségnek tekintem az olyan tényezőket, amelyek ugyan nem láthatóak a felhasználó számára,
  de jelentősen befolyásolják a rendszer karbantarthatóságát. Ide tartoznak az olyan dolgok, mint az
  architektúra konzisztenciája, teszt lefedettség, a kód olvashatósága vagy a refaktorálás.

Általánosságban egy kiemelkedő belső minőséggel rendelkező rendszer önmagában nem jelent jó külső
minőséget. Azonban egy rossz belső minőséggel rendelkező rendszer nagyon ritkán rendelkezik jó külső
minőséggel, mivel rendkívül nehéz jó dolgot építeni ha az alapozás düledezik.

A külső minőség a kiterjedés (scope) része. Esetenként üzleti szempontból teljesen elfogadható ha a
felhasználói felület lassú vagy nehéz használni, ha például egy későbbi kiadásban ezeket javítjuk.
Annak eldöntése, hogy ez tényleg megéri-e, a Product Owner dolga.

A belső minőség azonban nem vita tárgya. A csapat feladata minden körülmények között megőrízni a
rendszer jó minőségét és ebből nem engedünk soha, semmi szín alatt.

(Na jó, majdnem soha)

De hogyan is különböztetjük meg a belső és külső minőséget érintő kérdéseket?

Tegyük fel, hogy a Product Owner azt mondja: "Rendben, értem én, hogy 6 sztori pontra becsültétek,
de biztos vagyok benne, hogy fele idő alatt össze tudtok hozni egy gyors fixet, ha akarjátok."

Aha! A belső minőséget változónak próbálja tekinteni. Hogy miből tudom? Mert le akarja csökkenteni a
becslést anélkül, hogy azért fizetne a csökkentett kiterjedéssel. A "gyors fix" szó láttán
gondolatban meg kell szólalnia egy vészcsengőnek...

És hogy miért is nem hagyjuk ezt?

Az a tapasztalatom, hogy a belső minőség feláldozása szinte mindig nagyon nagyon rossz ötlet. Ami
időt nyerünk rajta, azt kamatostól elveszítjük mind rövid, mind pedig hosszú távon. Ha egy kódbázis
minősége elkezd romlani, akkor nagyon nehéz azt utólag helyrehozni.

Ehelyett megpróbálom a vitát a kiterjedés irányába terelni. "Mivel fontos hogy ezt a sztorit minél
előbb kiadhassuk, lecsökkenthetjük-e a méretét, hogy gyorsabban implementálhassuk? Például a
hibakezelést leegyszerűsítjük és később egy másik sztoriban dolgozunk a bonyolultabb hibakezelésen?
Vagy módosíthatjuk a többi feladat fontosságát, hogy inkább erre koncentrálhassunk?"

Ha a Product Owner megszokja, hogy a belső minőség nem egyezkedés tárgya, elég hamar ráérez, hogy
helyett hogyan befolyásolja a többi paramétert.

Véget nem érő Sprint Planning Meeting-ek...
-------------------------------------------
A legnehezebb dolog a Spring Planning Meetingekben, hogy:
1) Mindenki azt hiszi, hogy nem vesznek sok időt igénybe
2) ... de igen.

A Scrum-ban minden időkorlátozott. Szeretem ezt az egyszerű, konzisztens szabályt ls próbáljuk is
betartani.

Mit tegyünk, ha egy ilyen időkorlátozott Sprint Planning Meeting az időkorlát vége felé közeledik és
még nincs eldöntött Sprint cél vagy Sprint Backlog? Egyszerűen hagyjuk félbe? Vagy toljuk ki egy
órával? Vagy esetleg hagyjuk félbe, de folytassuk másnap?

Ez egy örökös probléma, főleg új csapatok esetében. Mit tegyünk hát? Fogalmam sincs. De mi általában
brutálisan félbeszakítjuk még ha ez a sprint rovására megy is. Egész pontosan azt mondom a csapatnak
és a Product Owner-ner, hogy "a meetingre kijelölt idő 10 perc múlva lejár és még nincs egy kézzel
fogható sprint tervünk. Próbáljunk meg ezzel gazdálkodni, vagy hívjunk össze egy új 4-órás meetinget
holnap reggel 8-ra?". Nem nehéz kitalálni, hogy általában mi a válasz... :)

Próbáltam kitolni a meetinget, de ez szinte soha sem vezetett semmire, mert az emberek már fáradtak.
Ha nem voltak képesek összehozni egy normális sprint tervet 2-8 óra alatt (vagy amilyen hosszúra
szabta az időkeretet) akkor valószínűleg egy további óra sem fog sokat számítani. A következő -
amúgy teljesen oké - opció, hogy összehívunk egy új meetinget a következő napra. Csakhogy általában
az emberek türelmetlenek és inkább nekikezdenének már a sprintnek ahelyett, hogy még egy napot
töltsenek sprint tervezéssel.

Úgyhogy félbevágom és igen, a sprint issza meg a levét. A jó oldala a dolognak viszont az, hogy a
csapat megtanult egy fontos leckét és a következő sprint planning meeting sokkal gördülékenyebben
fog menni. Ráadásul az emberek kevésbé fognak ellenkezni, ha egy olyan időkeretet szab, amit
egyébként túl hosszúnak tartanának.

Fontos, hogy megtanulja betartani az időkereteket és hogy realisztikus időkereteket szabjon meg. Ez
vonatkozik mind a meetingekre, mind pedig a sprint hosszára.

Sprint Planning Meeting napirend
--------------------------------
Egy előzetes menetterv készítése jelentősen lecsökkenti annak az esélyét, hogy a meeting kifut a
megszabott időkeretből.

Íme a tipikus menetrendünk.
Sprint Planning Meeting: 13:00- 17:00 (10 perc szünet minden órában)

* 13:00 - 13:30. A Product Owner ismerteti a sprint célját és összefoglalja a Termék Backlogot.
  Kijelölésre kerül a Demo helye és ideje.
* 13:30 - 15:00. A csapat elkészíti a becsléseket és lebontja a nagyobb feladatokat. A Product Owner
  frissíti a sztorik fontosságát. A feladatok pontosításra kerülnek. Minden fontos sztorihoz
  kitöltésre kerül a "Demo módja" mező.
* 15:00 - 16:00. A csapat kiválasztja a következő sprintbe kerülő elemeket. Ellenőrzik hogy a
  sztorik valóban beleférnek-e a sprintbe.
* 16:00 - 17:00. Kijelölésre kerül a Napi Scrum helye és ideje (ha eltér az előző sprinttől). A
  sztorik lebontása feladatokra.

Ezt a menetrendet nem tartatjuk be vasszigorral. A Scrum Master a körülményeknek megfelelően
hosszabbíthatja vagy rövidítheti az egyes lépéseket.

A Sprint hosszának megválasztása
--------------------------------
A Sprint Planning Meeting egyik eleme a sprint demo idejének megválasztása. Ez valójában a sprint
időtartamának megválasztását is jelenti.

Mit tekinthetünk jó Sprint hossznak?

Jó, ha a sprint rövid, mivel ez segíti a vállalat "agilitását", azaz, hogy gyakran képes irányt
váltani.
Rövid sprint = gyors visszajelzés = több kiadás = gyorsabb felhasználói visszajelzés = kevesebb idő
pazarlása vakvágányokon = gyorsabb adaptáció, stb...

De ugyanakkor a hosszabb sprintek is jók, mivel időt adnak a csapatnak hogy felgyorsuljanak és több
teret ad nekik a problémák megoldására, hogy végül a sprint célját teljesítsék; továbbá kevesebb
időt veszítenek a Sprint Planning Meetingeken vagy demókon.

A Product Owner-ek általában a rövid-, míg a fejlesztők hosszabb sprinteket szeretnek. A Sprint
hossza valójában kompromisszum kérdése. Elég sokat kísérleteztünk ezzel és végül a három hetes
sprint működött a legjobban nekünk. A legtöbb (de nem az összes) csapat 3 hetes sprinteket használ.
Elég rövid, hogy biztosítsa a vállalat flexibilitását, de elég hosszú, hogy a csapat megfelelően
koncentrálhasson és megoldhassa a sprint során esetlegesen felmerülő problémákat.

Az egyik tanulság, amit levontunk, hogy kezdetben érdemes kísérletezni különböző sprint hosszakkal.
Nincs szükség mélyreható vizsgálatra, csak válasszon egy jónak tűnő hosszot és próbálja ki egy pár
sprint erejéig.

Ha viszont megtalálta a legjobban fekvő sprint hosszat, akkor már ne nagyon változtasson rajta. Mi
egy pár hónap kísérletezgetés után arra jutottunk, hogy a három hét jó nekünk, szóval három hetes
sprinteket használunk és kész.

Néha ez túl hosszúnak fog tűnni és néha túl rövidnek. De az azonos hosszhoz ragaszkodás egyfajta
céges szívveréssé válik, amibe mindenki beleszokik. Nincsenek viták a kiadások időpontját illetően,
mivel mindenki tudja, hogy a kiadás három hetente történik. És kész.


A sprint céljának megválasztása
-------------------------------
Szinte mindig ugyanaz történik: a sprint planning meeting során felteszem a kérdést, hogy "tehát mi
is a sprint célja?" és mindenki csak bambán néz rá, miközben a Product Owner ráncolja a homlokát.

Valami megmagyarázhatatlan okból kifolyólag túl nehéz eldönteni a sprint célját, de arra kellett
rájönnöm, hogy megéri. Egy mondvacsinált cél is jobb, mint egy cél nélküli sprint. Az is megfelelő
cél, hogy "több pénzt csinálni" vagy "a legfontosabb három sztorit végigcsinálni" vagy "lenyűgözni a
főnököt" vagy "a bétatesztereknek kiadható állapotba hozni a rendszert" vagy "adminisztráció felület
létrehozása" vagy bármi. A lényeg, hogy üzleti és ne technológiai cél legyen, hogy a csapaton kívüli
emberek is megértsék.

A sprint célja arra az alapvető kérdésre ad választ, hogy "miért dolgozunk ezen a sprinten, miért
nem megyünk szabadságra helyette?". Ami azt illeti, az egyik módja, hogy a Product Ownerből
kiszedjük a sprint célját, hogy konkrétan feltesszük neki ezt a kérdést.

A cél persze egy olyan dolog kell, legyen, amit még nem értünk el. A "lenyűgözni a főnököt" megfelel
célnak, de értelmetlen, ha a főnök a jelenlegi rendszerrel is teljesen elégedett, ugyanis akkor
mindenki nyugodtan hazamehet és a cél úgy is teljesítve lesz.

Lehet, hogy a sprint célja bugyután hangzik a meetingen, de gyakran a sprint közepén jön elő a
haszna, amikor az tagok nem tudják, mit is csináljanak. Ha, ahogy mi is, egyszerre több Scrum
csapattal több terméken is dolgozik, hasznos összefoglalni a sprint célokat egy wiki oldalon vagy
hasonló helyen ahol az egész vállalat (nem csak a felsővezetés) hozzáférhet és megtekintheti, hogy
pontosan mit is csinál a cég - és miért.

A sprint alatt elvégzendő sztorik kiválogatása
----------------------------------------------
A sprint planning meeting egyik fő tevékenysége eldönteni, hogy mely sztorik kerülnek be a sprintbe.
Egész pontosan hogy a Product Backlog mely sztorijait másoljuk át a sprint backlogba.

<figure>

A fenti ábra minden téglalapja egy-egy sztorit jelez fontosság szerint rendezve. A legfontosabb
sztori a lista tetején található. A téglalap nagysága a sztori nagyságát jelképezi (azaz az
időmennyiség becslését sztori pontokban). A kék zárójel nagysága jelzi a csapat becsült sebességét,
azaz hogy az adott sprintben hány sztoripontnyi feladatot tudnak befejezni.

A jobb oldalon található sprint backlog a product backlogban található sztorik egy
pillanatfelvétele. Ez tartalmazza azokat a sztorikat, amelyeket a csapat be kíván fejezni az adott
sprintben.

A csapat dönti el, hogy hány sztorit vesznek be a sprintbe és nem a Product Owner vagy valaki más.
Ez két kérdést vet fel:
1. Hogyan dönti el a csapat, hogy melyik sztorikat vegye be a sprintbe?
2. Hogyan befolyásolhatja a Product Owner a döntésüket?

Először a második kérdésre válaszolnék.

Hogyan befolyásolhatja a Product Owner, hogy mely sztorik kerülnek be a sprintbe?
-----------------------------------------------------------------
Tegyük fel, hogy a következő szituáció áll elő a sprint planning meeting során:

<figure>

A Product Owner elégedtlen, hogy a D sztori nem került be a sprintbe. Milyen lehetőségei vannak?

Az első opció, hogy újraértékeli a fontosságokat. Ha D-nek adja a legnagyobb prioritást, akkor a
csapatnak kötelessége ezt bevenni a sprintbe (ebben az esetben a C sztorit kivéve a sprintből).

<figure>


A második lehetőség, hogy megváltoztatja a kiterjedést - az A sztorit addig egyszerűsíti, amíg a
csapat be nem tudja venni a D sztorit a sprintbe.

<figure>

A harmadik opció a sztorik kettévágása. A Product Owner dönthet úgy, hogy az A sztori néhány része
nem olyan fontos, tehát szétválaszthatja az A-t A1 és A2-re különböző fontossággal.

<figure>

Amint láthatja, bár a Product Owner nem szabályozhatja a becsült sebességet, azért több mód is
rendelkezésére áll, hogy befolyásolja a sprintbe kerülő sztorik listáját.

Hogyan dönti el a csapat, hogy mely sztorik kerüljenek a sprintbe?
------------------------------------------------------------------
Két taktikát szoktunk alkalmazni:
1. megérzés alapján
2. sebességszámítási alapján

Megérzés alapú becslés
* Scrum master: "Mit gondoltok, be tudjuk fejezni A-t ebben a sprintben?" (a product backlog
  legfontosabb elemére mutat)
* Lisa: "Simán! Három hetünk van rá és ez elég triviális feladat."
* Scrum master: "Oké, mi van, ha a B-t is bevesszük?" (a második legfontosabb elemre mutat)
* Tom és Lisa: "Naná!"
* Scrum master: "Oké, A, B és C együtt?"
* Sam (a Product Owner-hez): "C-ben benne van a teljes hibakezelés?"
* Product Owner: "Nincs, azt egyelőre kihagyhatjuk és csak az alap hibakezelést adjuk hozzá."
* Sam: "Akkor a C is belefér."
* Scrum master: "Oké, mi van, ha a D-t is hozzáadjuk?"
* Lisa: "Hmm..."
* Tom: "Szerintem belefér."
* Scrum master: "Mennyire biztos? 0%? 50%?"
* Lisa és Tom: "Közel 100%"
* Scrum master: "Oké, akkor a D-t bevesszük. Mi van az E-vel?"
* Sam: "Elképzelhető hogy belefér."
* Scrum master: "0%? 50%?"
* Sam: "Mondjuk 50% körül."
* Lisa: "Hát én nem tudom..."
* Scrum master: "Oké, E-t kihagyjuk. A, B, C és D mellett kötelezzük el magunk. Ha belefér, akkor
  persze E-t is befejezzük, de nem ígérünk semmit, hanem kihagyjuk a sprintből. Mit gondoltok?"
* Mindeki: "Rendben!"

Kis csapatokban és rövid sprintek esetén szokott jól működni a megérzés alapú tervezés.

Sebességszámítás alapú becslés
------------------------------
Ez a taktika két lépést igényel:
1. Megállapodni egy becsült sebességben
2. Kiszámítani, hogy hány sztori fér bele ebbe a sebességkeretbe

A sebesség az "elvégzett munka" mértékegysége, ahol minden elemet a kezdeti becslésével súlyozunk.

A lenti ábra egy példa a sprint kezdetén becsült sebességre és a sprint végén számított valós
sebességre. A téglalapok egy-egy sztorit jelölnek, a bennük található szám pedig a kezdeti becslés.

<figure>

Vegyük észre, hogy a valós sebesség a kezdeti becslésen alapul, azaz a sprint közben történt
változásokat figyelmen kívül hagyjuk.

Már hallom is, ahogy tiltakozik: "Dehát ez miért jó? A sebesség mértéke így egy csomó olyan tényezőn
múlik, mint hülye programozók, rossz kezdeti becslések, folytonosan növekvő feladatok, nem
betervezett akadályok ésatöbbi..."

Egyetértek abban, hogy ez egy körülbelüli érték, de attól még hasznos tud lenni és mindenképpen
több, mint a semmi. Remek kiindulópontot biztosít. "Minden tényezőtől függetlenül, íme a különbség
az előre megbecsült és a tényleges időtartam között."

Mi történik, ha egy sztorit nem sikerült teljesen befejezni a sprint alatt? Miért ne adnánk fél
pontokat a tényleges sebesség mérésekor? Ez jól tükrözi a Scrum (és minden agilis fejlesztési
módszertan) szellemiségét, vagyis hogy a legfőbb dolog befejezett, kiadható dolgokat készíteni. A
félkész termék értéke nulla (a valóságban akár negatív értéke is lehet). Ha többre kíváncsi ezzel
kapcsolatban, olvassa el Donald Reinertsen "A dizájn-gyár irányítása" című könyvét.

És hogy milyen feketemágiát használunk a sebesség becslésére?

Az egyik legegyszerűbb mód a sebesség becslésre a múltbeli értékek használata. Megnézzük, hogy
mennyi volt az elmúlt pár sprintben vett sebesség és feltételezzük, hogy nagyjából most is
ugyanannyi lesz.

Ezt a módszert "tegnapi időjárás"-nak is nevezik és csak olyan csapatok esetén működik, akik már
maguk mögött tudnak néhány sprintet és a következő sprintet is hasonló körülmények között csinálják,
ami persze nem minden esetben igaz.

Ennek egy fokkal bonyolultabb változatában az erőforrások alapján számítunk. Tegyük fel, hogy egy 3
hetes sprintet tervezünk (ami 15 munkanap) egy négyfős csapatban. Lisa kivett két nap szabadságot,
Dave csak az ideje felében tud segíteni és ráadásul az egyik napot szabadságon tölti.
Végeredményben:

<figure>

...vagyis ez 50 ember-napot jelent erre a sprintre.

Akkor a becsült sebességünk 50? Nem, mivel a becslésünk mértékegysége a sztori pont, ami esetünkben
nagyjából egy "ideális ember-nap"-nak felel meg. Egy ideális ember-nap egy tökéletesen hatékony és
zavartalan munkanap, ami a gyakorlatban nagyon ritkán fordul elő. Ráadásul számolnunk kell előre nem
tervezett feladatokkal, vagy esetleg lebetegedő emberekkel is.

Éppen ezért a becsült sebességünk biztosan kisebb lesz 50-nél. Node mennyivel kisebb? Erre
használjuk a "koncentrációs tényezőt".

<figure>

A koncentrációs tényező azt közelíti, hogy a csapat mennyire összpontosít. Ha ez a tényező alacsony,
az azt jelenti, hogy a csapat sok akadállyal számol vagy például nem bízik a saját becsléseiben.

A koncentrációs tényező számításakor legreálisabb az előző sprintet (vagy ami még jobb, az elmúlt
néhány sprint átlagát) alapul venni.

<figure>

A valós sebesség az előző sprintben befejezett sztorik kezdeti becslésének összege.

Tegyük fel, hogy egy három fős csapat (Tom, Lisa és Sam) az előző három hetes (45 ember-napos)
sprintben 18 sztori pontot fejezett be és próbáljuk megbecsülni a következő sprint sebességét.
Legyen a helyzet még bonyolultabb és csatlakozzon a csapathoz egy új ember, Dave. Mindent
egybevetve számoljuk egy 50 ember-napos sprinttel.

<figure>

Tehát az előzetes becslésünk 20 sztori pont, azaz hogy a csapat maximum 20 pont erejéig adhat
sztorikat a sprinthez.

<figure>

Ebben a helyzetben a csapat választhatja a legfelső 4 sztorit 1 sztori pont értékben vagy a felső 5
sztorit 24 értékben. Tételezzük fel, hogy ebben az esetben 4 sztorit választanak, mivel ez van
közelebb a 20 ponthoz. Kétség esetén inkább válasszon kevesebb sztorit.

Mivel a 4 sztori összesen 1 sztori pontot jelent, a végső sebesség erre a sprintre 1-nek adódik.

A tegnapi időjárás hasznos tud lenni, de csak ha nem gondolkodás nélkül használja. Ha az előző
sprint kivételesen rossz volt, mert a csapat felét egy hétre leverte a láz, akkor nyugodtan
feltételezheti, hogy ezúttal nem lesz ilyen pechje és használhat magasabb koncentrációs tényezőt. Ha
a csapat nemrég állított üzembe egy villámgyors continuous build rendszert akkor nyugodt szívvel
növelheti a koncentrációs tényezőt. Ha egy új tag érkezett a csapathoz, akkor nyugodtan csökkentse a
koncentrációs tényezőt, mivel valószínűleg időt fog igénybe venni a betanítása.

A minél pontosabb becslés érdekébe amikor csak lehet, használja a legutóbbi pár sprint átlagát.

De mi van, ha a csapat teljesen új és még nincs semmilyen múltbéli adata? Ez esetben használhatja
más csapatok hasonló helyzetben kapott koncentrációs tényezőjét. Ha nem ismer egyetlen más
hasonló csapatot sem, akkor nyugodtan csapjon a hasára, hiszen ez a tényező csak az első
sprintre vonatkozik, és utána már valós adatokra fog tudni hivatkozni.

Számomra az "alapértelmezett" koncentrációs tényező új csapatok esetében általában 70%, mivel a
legtöbb csapatom valahol e körül mozgott.

Melyik becslési technikát használjuk?
-------------------------------------
A fentiekben ismertettem néhány technikát, a megérzésen alapuló becsléstől kezdve a tegnapi
időjáráson át a rendelkezésre álló munkanapokon és a koncentrációs tényezőn alapuló számításig.

Hogy mi melyik technikát használjuk?

Általában a fentiek valamilyen elegyét használjuk, ami nem igazán vesz sok időt igénybe.

Kezdetnek megnézzük az előző sprint tényleges sebességét és koncetrációs tényezőjét, majd
összevetjük ezt a következő sprintre számított rendelkezésre állással és megbecsüljük a
koncentrációs tényezőt. Ha a kettő között jelentős eltérések adódnak, akkor azt megbeszéljük és a
végén megegyezünk egy értékben.

Ha már van egy előzetes sztori listánk erre a sprintre, akkor megnézem, hogy mennyire érzem
reálisnak, illetve a csapatot is megkérem, hogy egy pillanatra felejtsék el a pontokat és mondják
el, hogy mennyire érzik reálisnak ez a lista a sprintre. Ha túl soknak tűnik, akkor kihagyunk egy
sztorit, ha túl soknak, hozzáadunk egyet.

Végső soron a cél mindössze annyi, hogy kiválasszuk a sprintbe kerülő sztorikat. A koncentrációs
tényezők, erőforrás rendelkezésre-állások és becsült sebességek mindössze eszközök arra, hogy ezt a
célt elérjük.

Miért használunk cetliket
-------------------------
A sprint planning meeting nagy részében a product backlog sztorijait becsüljük, rendezzük őket
fontosság alapján, tisztázzuk vagy épp kisebb feladatokra osztjuk őket.

Ez a gyakorlatban hogy is néz ki?

Régebben kivetítettük a product backlogot tartalmazó Excel-t és valaki (tipikusan vagy a Product
Owner vagy a Scrum Master) a billentyűzet mellől végigment az egyes sztorikon elindítva a
beszélgetést. Amikor például a fontosság vagy bármi egyéb részlet változott, ez a valaki frissítette
a sztorit közvetlenül az Excel táblában.

Remekül hangzik? Hát nem az, hanem szívás. És ami a legrosszabb, hogy a csapat általában észre sem
veszi, hogy mekkora szívás amíg a meeting a vége felé nem közeledik és még mindig nem sikerült
végigmenni a sztorik listáján.

Sokkal hatékonyabb megoldásnak találtuk a falra (vagy egy nagyobb asztalra) ragasztott cetliket.

<figure>

Ez a következő szempontok alapján messze jobb a kivetítőnél:
* Az emberek állnak és körbesétálhatnak => tovább maradnak éberek
* Sokkal személyesebb élményt nyújt (mintha csak egyvalakinél lenne a billentyűzet)
* Egyszerre több sztorin lehet dolgozni
* Triviális dolog átrendezni a fontosság alapján
* A meeting után a cetlik könnyen átvihetőek a csapat szobájába és közvetlenül használhatóak a fali
  feladat-térképen. (Lásd: "Hogyan használjuk a Sprint Backlogot")

Írhatja kézzel is (mi kézzel írjuk) de használhat például egy szkriptet, ami ezeket a cetliket
közvetlenül a Product Backlog-ból generálja.

<figure>

Ui: a blogomról letölthető a szkript, amit mi használunk: http://blog.crisp.se/henrikkniberg

Fontos! A Sprint Planning Meeting után a Scrum Master feladata kézzel frissíteni a product backlogot
tartalmazó Excel táblát a cetlik alapján. Igen, ez némi többletmunkát jelent, de ez eltörpül a
Sprint Planning Meetingben nyert hatékonyság mellett.

Egy gyors megjegyzés a "Fontosság" mezőről. A cetli készítésekor ez az Excel táblában található
fontosságot tartalmazza, ami abban segít, hogy egyszerűen rendezhessük a cetliket fontosság alapján
(nálunk átalában balról jobbra csökken a fontosság). Ha a cetlik már felkerültek a falra, akkor már
nincs szükség ezekre a számértékekre, helyette egyszerűen a fizikai elhelyezkedés jelzi a
fontosságot. Ha a Product Owner felcserél két cetlit, ne vesztegessen időt a fontosság mező
frissítésével, elég ha a meeting után frissíti az Excel táblát.

Az időbecslések általában egyszerűsödnek (és pontosabbá válnak) ha a sztorit kisebb feladatokra
bontjuk. Mi általában az "aktivitás" szót használjuk, mert svéd nyelven a "feladat" szónak teljesen
más a jelentése. Ez a felbontás is egyszerű a cetlik használatával, sőt több sztorit is könnyen szét
lehet bontani párhuzamosan.

Ezt úgy szoktuk csinálni, hogy a sztori alá újabb cetliket ragasztunk, ahol minden cetli egy-egy
feladat a sztorin belül.

<figure>

<figure>

Nem szoktuk felvezetni az Excel-alapú product backlogba a feladatokat már csak két okból sem:
* A feladatok elég gyakran változnak a sprint során és túl sok munka lenne állandóan szinkronizálni
  a backlogot.
* A Product Owner amúgy sem kell, hogy részt vegyen ezen a szinten

Ahogy a sztori cetliket, úgy a feladat cetliket is közvetlenül fel lehet használni a sprint
backlogban (Lásd "Hogyan használjuk a Sprint Backlogot")

A "kész" definíciója
--------------------
Nagyon fontos, hogy a Product Owner és a csapat megegyezzen a "kész" pontos definíciójában. Készen
van-e a sztori, amikor a kódot becsekkoljuk a verziókövető rendszerbe? Vagy esetleg csak akkor,
amikor telepítettük a teszt rendszerre és az integrációs teszter csapat leellenőrizte? Mi a legtöbb
esetben úgy definiáljuk a "készt", mint "éles telepítésre készen", de néha csak annyit tudunk
mondani, hogy "telepítve a teszt rendszerre és tesztre készen áll".

Kezdetben részletes listát készítettünk ehhez, de újabban azt tartjuk, hogy "egy sztori akkor van
kész, amikor a csapat azt mondja, hogy kész van". Ezután már a teszterek dolga biztosítani, hogy a
csapat tényleg megértette a Product Owner szándékát és hogy a sztori megfelel az előre megegyezett
követelményeknek.

Arra jöttünk rá, hogy nem lehet minden sztorit ugyanúgy kezelni. A "Felhasználó-keresés" teljesen
más, mint például a "Üzemeltetői kézikönyv", mivel az utóbbi esetében a "kész" definíciója lehet,
hogy egyszerűen csak az, hogy "az üzemeltető csoport elfogadta". A legtöbb esetben a józan ész
használatával jobb eredményt lehet elérni, mint egy részletes listával.

Ha gyakran merül fel probléma a "kész" definíciója kapcsán, érdemes lehet a sztorikhoz külön
hozzáadni egy "kész definíciója" mezőt"

Időbecslés Planning Poker-rel
------------------------------------
A becslés csapattevékenység, azaz a csapat minden tagja részt vesz minden sztori becslésében.
Hogy miért?
* A sprint tervezés folyamán általában még nem tudjuk, hogy az egyes részeket ki fogja majd
  implementálni.
* A sztorik általában több különböző szakértelmet igényelnek (felhasználói felület dizájn,
  programozás, tesztelés, stb...)
* A becsléshez elengedhetetlen, hogy tudjuk, hogy a sztori miről szól. Azzal, hogy mindenkit
  megkérdezünk, voltaképp azt biztosítjuk, hogy mindenkinek lesz valamennyi fogalma az adott
  sztoriról, ami cserében megnöveli annak a valószínűségét, hogy a csapattagok a sprint során
  segítenek majd egymásnak. Abban is segít továbbá, hogy a fontos kérdések már az elején
  előjöjjenek.
* Azzal, hogy mindenkit megkérdezünk, gyakran előfordul, hogy két csapattag drasztikusan különböző
  becslést ad ugyanarra a sztorira. Az így felmerülő kérdéseket jobb a lehető leghamarabb tisztázni.

Amikor egy csapatot arra kér, hogy becsüljön meg egy feladatot, általában a feladatot legjobban
ismerő tag fog először előállni egy becsléssel, ám ezzel befolyásolja a többiek döntését.

Van egy remek stratégia ennek elkerülésére - úgy hívják, hogy Planning Poker (ha jól emlékszem Mike
Cohn találmánya)

<figure>

Minden tag kap egy a fentiekhez hasonló 13 kártyából álló paklit. Amikor egy sztorit becslünk, az
egyes tagok kiválasztják és lefordítva az asztalra teszik azt a lapot, amely szerintük a becsült
időtartamot (sztori pontban) a lejobban képviseli. Amikor mindenki készen áll, a kártyákat egyszerre
megfordítják. Így mindenki saját maga kell, hogy döntsön és nem hagyatkozhat senki valaki más
becslésére.

Ha drasztikus eltérés van két érték között, akkor a csapat megbeszéli a különbségeket és megpróbál
egy lapra kerülni a sztorit illetően. Ha kell, a feladatok részekre is bonthatják és újra
becsülhetnek. Ezt a folyamatot addig ismétlik, amíg konszenzusra nem jutnak (azaz a becslések
nagyjából azonosak).

Fontos emlékeztetni a csapatot, hogy a teljes munkát kell megbecsülniük és nem csak a "saját"
részüket, vagyis egy teszter nem csak a tesztekre szükséges időt méri fel.

Vegyük észre, hogy a számsorozat nem lineáris, azaz például nincs semmi 40 és 100 között. Miért van
ez?

Ezzel próbáljuk meg eloszlatni annak illúzióját, hogy pontosan tudjuk becsülni a nagy időtartamokat.
Ha egy sztorit 20 pontra becsültük, akkor nem igazán fontos azon vitázni, hogy ez pontosan 20 vagy
18 vagy 21. Elég annyit tudnunk, hogy ez egy nagy feladat, amit nehéz előre felbecsülni, mi
nagyjából 20 pontra gondoljuk.

Ha ennél pontosabb becslést szeretne, válassza szét a sztorit több kisebbre és becsülje azokat
inkább.

És nem ér csalni úgy, hogy egy 5-t és egy 2-t összerakva 7-t becsül. Vagy az 5-t vagy a 8-t kell
választani, nincs olyan becslés, hogy 7.

Néhány különleges lap:
* 0 = "ezt a sztorit már befejeztük korábban" vagy "ez teljesen triviális, legfeljebb pár percnyi
  munka".
* ? = "halvány lila gőzöm sincs, de tényleg."
* kávé = "túl fáradt vagyok gondolkodni, tartsunk pár perc szünetet."

Sztorik pontosítása
-------------------
A lehető legrosszabb dolog amikor a csapat nagy büszkén bemutatja a működő új dolgot a sprint
demóban, de a Product Owner szomorúan közli, hogy "igen, ez szép és jó, csak épp nem ezt kértem".

Hogyan lehetünk biztosak, hogy a csapat és a Product Owner elképzelés a sztoriról ugyanaz, vagy
például hogy a csapattagok elképzelése ugyanaz? A rossz hír, hogy sosem lehet teljesen biztos,
viszont van néhány stratégia a nyilvánvaló félreértések felderítésére. Legegyszerűbben azzal
segíthet, hogy a sztorihoz tartozó összes mezőt kitölti (egész pontosan az összes fontos és ezáltal
a sprintbe valószínűleg bekerülő sztorihoz tartozó összes mezőt).

1. Példa:
Mind a csapat, mind a Product Owner elégedett a sprint tervével és már a meeting befejezésén
gondolkodnak, amikor a Scrum Master megszólal: "várjunk csak, itt ez a 'felhasználó hozzáadása'
sztori, amihez még nincs becslés." Néhány oda-vissza múlva a csapat megegyezik 20 pontban, amire a
Product Owner dühösen felpattan: "Micsoda???" Pár percnyi heves vita után kiderül, hogy a csapat
félreértette a feladatot és arra gondolt, hogy a 'felhasználó hozzáadása' egy 'szép webes felület,
felhasználó hozzáadására, törlésére, keresésére', miközben a Product Owner mindössze arra gondolt,
hogy 'felhasználók hozzáadása manuálisan, valami egyszerű SQL használatával". Újabb becslés után
végül 5 pontban állapodnak meg.

2. Példa:
Mind a csapat, mind a Product Owner elégedett a sprint tervével és már a meeting befejezésén
gondokkoznak, amikor a Scrum Master megszólal: "várjunk csak, itt ez a 'felhasználó hozzáadása'
sztori, ezt hogyan fogjuk demonstrálni?". Pár perc tanácstalanság után valaki feláll és azt mondja
"no igen, először is belépünk a weboldalra és...", amire a Product Owner közbevág: "Mi az, hogy
belépünk a weboldalra? Nem, nem nem és nem, ez a sztori egyáltalán nem része a weboldalnak, csak egy
egyszerű SQL szkript az adminoknak".

A "hogyan demonstráljuk" mező legyen minél tömörebb, egyébként sosem fog végezni a Sprint Planning
Meetinggel. Mindössze egy áttekintő és könnyen érthető teszt előírás a legtipikusabb esetekhez: "ezt
és ezt csináld, majd ez történik és így ellenőrizhető a dolog". Pályafutásom során többször segített
ez az egyszerű leírás felfedni kisebb-nagyobb félreértéseket. És minél előbb sikerül őket
felfedezni, annál jobb!


Sztorik felbontása kisebb sztorikra
------------------------------------------
A sztorik ne legyenek se túl kicsik, se túl nagyok (a becsült érték alapján). Ha egy csomó fél
pontos sztorija van, akkor valószínűleg a mikromenedzsment áldozata. Ugyanakkor egy 40 pontos sztori
nagy valószínűséggel csak félig fog elkészülni, ami nem túl hasznos a vállalatnak. Ráadásul ha a
becsült sebesség 70 és a két legfontosabb sztori 40 40 pontos, akkor elég nehéz sprintet tervezni.
Vagy kevesebbet vesz fel a listára (esetünkben csak egy sztorit) vagy túl sokat (a két legfontosabb
sztorit).

Az a tapasztalatom, hogy egy nagy sztorit szinte mindig fel lehet bontani kisebb sztorikra és csak
arra kell ügyelni, hogy a kisebb sztorik is kézzelfogható üzleti értéket képviseljenek.

Általában arra törekszünk, hogy a sztorijaink 2-8 ember-nap körül legyenek. Mivel a sebességünk
valahol 40 és 60 között mozog, ez nagyjából 10 sztorit jelent egy sprintben. Néha ez az érték csak 5
és néha akár 15 is, de ezek mindegyike teljesen kezelhető a cetlis módszerrel.

Sztorik felbontása feladatokra
------------------------------
Itt álljunk meg egy pillanatra és tisztázzuk, hogy mi a különbség a sztorik és a feladatok között.

Igazából a különbség viszonylag egyszerű: a sztorik olyan dolgok, amik fontosak a Product Owner
számára, míg a feladatok vagy nem önmagukban kiadhatóak, vagy olyan dolgok, amik nem számítanak a
Product Ownernek.

Példa egy sztori kisebb sztorikra darabolására:

<figure>

Példa egy sztori feladatokra osztására:

<figure>

Néhány figyelemre méltó észrevétel:
* Új Scrum csapatok általában húzódzkodnak a sztorik feladatokra bontásától, mivel úgy érzik, hogy
  ez túlságosan is hasonlít a vízesés-modellre.
* Olyan sztorik esetében, amit mindenki tökéletesen ért, utólag is ugyanolyan egyszerű a feladatokra
  bontás.
* A feladatokra bontás eredményeként gyakran kerülnek elő új részletek és az időtartamra adott
  becslések gyakran növekednek, cserében viszont a sprint terve sokkal életszerűbbé válik.
* A felbontásnak köszönhetően a Napi Scrum sokkal hatékonyabbá válik (lásd "Hogyan használjuk a Napi
  Scrum-ot")
* Még ha a felbotás pontatlan és később módosításokra szorul is, a fenti előnyök akkor is jelen
  vannak.

Éppen ezért úgy próbáljuk ütemezni a sprint tervezést, hogy a feladatokra bontás is beleférjen,
azonban nem nagy tragédia, ha mégis kifutunk az időből (Lásd: "Hol húzzuk meg a határt")

Megyjegyzés: Mivel TDD-t (Teszt Alapú Fejlesztés) használunk, a gyakorlatban az első feladat mindig
a "meghiúsuló teszt írása" és az utolsó mindig "refaktorálás" (= a kód olvashatóságának javítása és
duplikált kód eltávolítása).


A Napi Scrum helyének és idejének kijelölése
--------------------------------------------
A sprint planning meeting egy gyakran elfelejtett része a "Napi Scrum helyének és idejének
kijelölése". Enélkül viszont a sprint elég rosszul kezdődik, mivel az első napi scrum gyakorlatilag
az a hely, ahol a tagok eldöntik, hogy min is dolgozzanak.

Én a reggeli meetingek híve vagyok, de be kell valljam, hogy tulajdonképpen sosem próbáltuk délre
vagy délutánra ütemezni a napi scrumot.

A délután tartott scrum meeting hátránya, hogy reggel emlékezni kell arra, hogy mit is mondott
tegnap, min fog ma dolgozni.

A reggeli scrum meeting hátránya, hogy reggel emlékezni kell, hogy mit is csinált tegnap.

Véleményem szerint az előbbi hátránya jelentősebb, mivel a legfontosabb nem az, hogy mit csinált
eddig, hanem hogy mit fog csinálni.

Mindig azt a legkorábbi időpontot próbáljuk választani, amire már senki sem morog. Ez általában
9:00, 9:30 vagy 10:00, de a legfőbb, hogy olyan időpontot válasszon, amibe a csapat minden tagja
beleegyezik.

Hol húzzuk meg a határt
-----------------------
Rendben, az idő nagyon fogytán van, mit hagyhatunk ki a sprint planning meetingből?

Én általában az alábbi fontossági sorrendet használom:

1: A Sprint célja és a demó időpontja. Ez az abszolút minimum a sprint elkezdéséhez. Ha
a cél világos és meg lett választva a sprint vége, a csapat elkezdhet dolgozni közvetlenül a Product
Backlogból, ami persze szívás és komolyan érdemes elgondolkodni egy új meeting összehívásán, de ha
tényleg muszáj elkezdeni a sprintet, akkor ez is megteszi. Ugyanakkor őszintén szólva én ennyi
információval még sosem kezdtem sprintet.
2: A sprintbe felvett sztorik listája
3: Az összes sztori időtartama becsülve
4: "Demó módja" kitöltve az összes sprintbe foglalt sztorihoz
5: Sebességkalkuláció. A csapattagok listája és rendelkezésre állásuk mértéke (ami nélkül nem lehet
a sebességet számítani)
6: A napi scrum helyének és idejének kijelölése. Ez legfeljebb egy pár percet vesz igénybe, de ha
kifut az időből, a Scrum Master utólag is dönthet és emailben értesítheti a csapattagokat.
7: A sztorik felbontása feladatokra. Ezt lehet naponta is csinálni a Napi Scrum keretein belül, de
az valamennyire megtöri a sprint lendületét.

Technikai sztorik
-----------------
A technikai jellegű sztorik (vagy nem-funkcionális elemek) meglehetősen összetett problémát
jelentenek.

Olyan dolgok ezek, amiket meg kell csinálni, de nem közvetlenül kiadhatóak és nem igazán tartoznak
egyik másik sztorihoz sem, ráadásul nem képviselnek közvetlenül értéket a Product Owner számára.

Például:
* Continuous build rendszer telepítése
  o azért kell, mert rengeteg időt megspórol a fejlesztők számára és csökkenti annak esélyét, hogy
  az iteráció végén integrációs problémák lépnek fel.
* Áttekintő rendszerterv készítése
  o azért szükséges, mert a fejlesztők nem tudják állandóan fejben tartani a rendszer felépítését és
  ez inkonzisztens kódot eredményez. Szükséges egy áttenkintő dokumentum, amire a tagok rendszeresen
  hivatkozhatnak.
* Adatbázis-elérési réteg refaktorálása
  o azért szükséges, mert az adatbázis-elérési réteg eléggé rossz álltapotban van már, ami lassítja
  a fejlesztést a sok hiba és félreértés miatt. A kód megtisztításával rengeteg időt lehet
  megtakarítani és azzal egyidőben a rendszer stabilitása is nő.
* JIRA (hibakövető) frissítése
  o azért kell, mert a jelenlegi verzió túl lassú és bugos, a frissítés sok időt takarít meg.

Ezek vajon normális sztorik, vagy esetleg olyan feladatok, amik nem tartoznak egy konkrét sztorihoz
sem? Ki határozza meg a fontosságukat? Egyáltalán a Product Owner szükséges az ilyen dolgokhoz?

Mi több különböző módszert is kipróbáltunk. Használtunk sztorikat rájuk, ami nem igazán működött,
mert a Product Ownernek nem volt viszonyítási alapja amikor a Product Backlogot rendezte fontossági
sorrendbe. Ami azt illeti, a technikai jellegű sztorik gyakran kaptak alacsony prioritást olyan
dolgokra hivatkozva, mint "értem én, hogy a continuous build rendszer fontos, de azért próbáljuk a
valós bevételt jelentő sztorikat megcsinálni először, aztán majd gondolkodhatunk ezeken a technikai
izéken, értem?"

Az esetek egy részében persze igaza van, ám nagyon gyakran nincs. Arra jutottunk, hogy a Product
Owner nem mindig a megfelelő személy a fontosság eldöntésére.

Ehelyett az alábbiakat tesszük:
1) Amennyire csak lehet kerüljük a technikai jellegű sztorikat és megpróbáljuk őket valamiféle
mérhető üzleti értéket biztosító sztorivá változtatni, hogy a Product Owner könnyebben mérlegelhesse
a fontosságát.
2) Ha ez nem lehetséges, akkor megpróbáljuk egy másik sztori keretein belül elvégezni a munkát.
Például az "adatbázis-elérési réteg refaktorálása" elvégezhető a "felhasználó adatainak
szerkesztése" sztori keretein belül, mivel az érinti az adatbázis-elérési réteget.
3) Ha ez sem kivitelezhető, akkor technikai jellegű sztoriként vesszük fel, ám egy különálló
listára, amit a Product Owner megtekinthet, ám nem szerkeszthet. A "koncentrációs tényező" és
"becsült sebesség" értékeket használva megpróbálunk megegyezni a Product Ownerrel, hogy a sprint egy
részét a technikai sztorikra fordíthassuk.

Példa (az alábbihoz kísértetiesen hasonló párbeszéd zajlott le az egyik sprint planning
meetingünkön)
* Csapat: "Van pár belső technikai jellegű feladat, amit jó lenne megcsinálni. Szeretnénk erre
  használni az időnk 10%-t, vagyis csökkentsük a koncentrációs tényezőt 75%-ról 65%-ra. Ez
  elfogadható?"
* Product Owner: "A frászt fogadható el, nincs most erre időnk!"
* Csapat: "Nézd, az előző sprintben a becsült sebességünk 80 volt, de a végére a valós sebességünk
  csak 30-ra jött ki."
* PO: "Pontosan, ezért nincs időnk ilyen technikai dolgokra, muszáj végezni az új feladatokkal."
* Csapat: "Igazából azért teljesítettünk ilyen rosszul, mert túl sok időt töltöttünk azzal, hogy a
  release tesztre kész állapotba kerüljön."
* PO: "Igen, és?"
* Csapat: "Szóval valószínűleg a sebességünk ezután is ilyen rossz marad, hacsak nem teszünk
  valamit."
* PO: "Igen, és?"
* Csapat: "Szóval azt javasoljuk, hogy a következő sprintből szánjunk 10%-ot egy continuous build
  szerver és hasonló eszközök telepítésére, amivel egyszerűbbé válik az integráció. Ez legalább
  20%-os sebességnövekedést fog jelenteni az összes utána következő sprintben."
* PO: "Tényleg? Miért nem csináltuk ezt meg az előző sprintben?"
* Csapat: "Ööö, mert te nem akartál hallani se róla."
* PO: "Ööö, oké, így elmondva jó ötletnek tűnik."

Persze egy másik megoldás, a Product Owner-t teljesen kihagyni az egészből és nem engedni a
javasolt koncentrációs tényezőből, de célszerű legalább megpróbálni konszenzusra jutni vele.

Amennyiben a Product Owner hozzáértő és értelmes ember (és ebben mi nagyon szerencsések voltunk), én
azt javaslom, hogy amennyire csak lehet beszéljen vele és hagyja, hogy ő hozza meg a fontosságot
illető döntéseket. Végül is az áttekinthetőség a Scrum egyik alapértéke.

Hibakövető rendszer és a Product Backlog
----------------------------------------
Az Excel egy remek formátum a Product Backloghoz, de mindenképp szükség van hibakövető rendszerre
is, amire viszont az Excel nem a legjobb választás. Mi például JIRA-t használunk.

De hogyan hozzuk a JIRÁ-ban található feladatokat a sprint planning meetingre? Az azért mégsem
járható út, hogy egyszerűen elfelejtjük őket és csak a sztorikra koncentrálunk.

Itt is többféle stratégiával próbálkoztunk:
1) A Product Owner kinyomtatja a legfontosabb JIRA bejegyzéseket és ezeket tesszük a többi sztori
mellé a falra (amivel egyben a többi sztorihoz viszonyított fontosságuk is meghatározásra kerül)
2) A Product Owner olyan sztorikat készít, amelyek hivatkoznak a JIRA bejegyzésekre, például "A
legfőbb hibák kijavítása: Jira-124, Jira-126 és Jira-180".
3) A hibajavítás nem tekintjük a sprint részének, azaz a csapat elég alacsonyan tartja a
koncentrációs tényezőt (például 50%), hogy maradjon idő a hibák kijavítására. Ezzel gyakorlatilag
implicite feltételezzük, hogy a csapat az ideje egy részét minden sprintben hibák javításával tölti.
4) A Product Backlogot is JIRÁ-ban tároljuk (azaz kidobjuk az Excelt). A hibákat is normális
sztoriként jegyezzük.

Nem igazán sikerült még eldönteni, hogy melyik stratégia a legjobb, mivel ez csapatról csapatra és
sprintről sprintre változik. Én az első stratégia felé hajlok, mivel az elég egyszerű.

A Sprint Planning Meeting vége
------------------------------
Váó, nem gondoltam volna, hogy ilyen hosszúra nyúlik majd ez a fejezet. Ez valahol biztos azt
tükrözi, hogy talán a Scrum legfontosabb részének tartom a Sprint Planning Meetinget. Ha elég időt
szán ennek tökéletesítésére, a maradék sokkal egyszerűbb lesz.

A Sprint Planning Meeting akkor tekinthető sikeresnek, ha mindenki (az összes csapattag és a Product
Owner) is mosolyogva távozik és másnap is mosollyal ébred és kezdi meg az első Napi Scrum-ot.

De persze van egy csomó dolog, ami még összeomolhat a sprint során, de legalább a sprint terve
tökéletes volt. :)

5 Hogyan kommunikáljuk a sprinteket
===================================
Ha nem informáljuk az egész vállalatot, az könnyen vezethet elégedetlenséghez, vagy - ami még
rosszabb - hibás feltételezésekhez.

Erre való a "Sprint adatlap".

<figure>

Néha a sztorik demonstrálásának módját is jelezzük.

A Scrum Master feladata ezt az oldalt elkészíteni, a wikire feltölteni és a vállalat minden
alkalmazottjának elküldeni a linket emailben.

<figure>

Ezen túl a wikiben van még egy "állapotjelző" oldalunk is, amelyről linkek vezetnek az összes
folyamatban lévő sprint oldalára.

<figure>

A Scrum Master feladata továbbá a sprint adatlapot kinyomtatni és a csapat szobájának ajtajára
tűzni, hogy bárki, aki arra jár láthassa, hogy a csapat éppen min dolgozik. Mivel ez tartalmazza a
napi scrum helyét és idejét, tudja, hogy hova kell mennie, ha többre kíváncsi

Amikor a sprint a végéhez közeledik, a Scrum Master kötelessége emlékeztetni mindenkit a demóra.

<figure>

Mindezek mellett igazán senki sem találhat kifogást, hogy miért nem tudta, hogy mi történik.

6 How we do sprint backlogs
===========================
You made it this far? Whew, good
job.

So now that we’ve completed the sprint planning meeting and told the world about our shiny
new sprint, it is time for the Scrum master to create a sprint backlog. This needs to be
done after the sprint planning meeting, but before the first daily scrum.

Sprint backlog format
---------------------
We’ve experimented with different formats for the sprint backlog,
including Jira, Excel, and a physical taskboard on the wall. In the beginning we used Excel
mostly, there are many publicly available Excel templates for sprint backlogs, including
auto generated burn-down charts and stuff like that. I could talk a lot about how we refined
our Excel-based sprint backlogs. But I won’t. I won’t even include an example here.

Instead I’m going to describe in detail what we have found to be the most effective format
for the sprint backlog – a wall-based taskboard!

Find a big wall that is unused or contains useless stuff like the company logo, old diagrams
or ugly paintings. Clear the wall (ask for permission only if you must). Tape up a big, big
sheet of paper (at least 2x2 meters, or 3x2 meters for a large team). Then do this:

<figure>

You could of course use a whiteboard. But that’s a bit of a waste. If possible, save
whiteboards for design scrawls and use non-whiteboard walls for taskboards.

NOTE – if you use post-its for tasks, don’t forget to attach them using real tape, or
you’ll find all the post-its in a neat pile on the floor one day.

How the taskboard works
-----------------------

<figure>

You could of course add all kinds of additional columns. “Waiting for integration test”
for example. Or “Cancelled”. However before you complicate matters, think deeply. Is
this addition really, really necessary?

I’ve found that simplicity is extremely valuable for these types of things, so I only
add additional complications when the cost of not doing so is too great.

Example 1 – after the first daily scrum
---------------------------------------
After the first daily scrum, the taskboard might
look like this:

<figure>

As you can see, three tasks have been "checked out", i.e. the team will be working on
these items today.

Sometimes, for larger teams, a task gets stuck in “checked out” because nobody remembers
who was working on it. If this happens often in a team they usually introduce policies
such labeling each checked out task with the name of the person who checked it out.

Example 2 – after a few more days
---------------------------------
A few days later the taskboard might look something
like this:

<figure>

As you can see we’ve completed the “deposit” story (i.e. it has been checked in to the
source code repository, tested, refactored, etc). The migration tool is partially
complete, the back office login is started, and the back office user admin is not
started.

We’ve had 3 unplanned items, as you can see down to the right. This is useful to
remember when you do the sprint retrospective.

Here’s an example of a real sprint backlog near the end of a sprint. It does get rather
messy as the sprint progresses, but that’s OK since it is short- lived. Every new sprint
we create a fresh, clean, new sprint backlog.

<figure>

How the burndown chart works
----------------------------
Let’s zoom in on the burndown chart:

<figure>

This chart shows that:
* On the first day of the sprint, august 1, the team estimated that
there is approximately 70 story points of work left to do. This was in effect the
estimated velocity of the whole sprint.
* On august 16 the team estimates that there is
approximately 15 story points of work left to do. The dashed trend line shows that they
are approximately on track, i.e. at this pace they will complete everything by the end
of the sprint.

We skip weekends on the x-axis since work is rarely done on weekends.
We used to
include weekends but this would make the burndown slightly confusing, since it would
“flatten out” over weekends which would look like a warning sign.

Taskboard warning signs
-----------------------
A quick glance at the taskboard should give anyone an indication
of how well the sprint is progressing. The Scrum master is responsible for making sure
that the team acts upon warning signs such as:

<figure>

<figure>

<figure>

<figure>

Hey, what about traceability?!
------------------------------
The best traceability I can offer in this model is to
take a digital photo of the taskboard every day. If you must. I do that sometimes but
never find a need to dig up those photos.

If traceability is very important to you, then perhaps the taskboard solution is not for
you.

But I suggest you really try to estimate the actual value of detailed sprint
traceability. Once the sprint is done and working code has been delivered and
documentation checked in, does anyone really care how many stories were completed at day
5 in the sprint? Does anyone really care what the time estimate for “write a failing
test for Deposit” was?

Estimating days vs. hours
-------------------------
In most books and articles on Scrum you’ll find that tasks are
time- estimated in hours, not days. We used to do that. Our general formula was: 1
effective man-day = 6 effective man-hours.

Now we’ve stopped doing that, at least in most of our teams, for the following reasons:
* Man-hour estimates were too fine-granular, this tended to encourage too many tiny 1-2 hour tasks
and hence micromanagement.
* It turned out that everyone was thinking in
terms of man-days anyway, and just multiplying by 6 before writing down man- hours.
“Hmmmm, this task should take about a day. Oh I have to write hours, I’ll write 6 hours
then”.
* Two different units cause confusion. “Was that estimate in man- days or man-hours?”.

So now we use man-days as a basis for all time estimates (although we call it story
points). Our lowest value is 0.5, i.e. any task that is smaller than 0.5 is either
removed, combined with some other task, or just left with a 0.5 estimate (no great harm
in overestimating slightly). Nice and simple.

7 How we arrange the team room
==============================

The design corner
-----------------
I’ve noticed that many of the most interesting and valuable design
discussions take place spontaneously in front of the taskboard.

For this reason, we try to arrange this area as an explicit “design corner”.

<figure>

This is really quite useful. There is no better way to get an overview of the system
than to stand in the design corner and glance at both walls, then glance at the computer
and try the latest build of the system (if you are lucky enough to have continuous
build, see pg 81 “How we combine Scrum with XP”).

The “design wall” is just a big whiteboard containing the most important design scrawls
and printouts of the most important design documentation (sequence charts, GUI
prototypes, domain models, etc).

<figure>
Above: a daily scrum going on in the aforementioned corner.

Hmmmm..... that burndown looks suspiciously nice and straight doesn’t it. But the team
insists that it is real :o)

Seat the team together!
-----------------------
When it comes to seating and desk layout there is one thing
that can’t be stressed strongly enough.

Seat the team together!

To clarify that a bit, what I’m saying is

!!! Seat the team together !!!

People are reluctant to move. At least in the places I’ve worked. They don’t want to
have to pick up all their stuff, unplug the computer, move all their junk to a new desk,
and plug everything in again. The shorter the distance, the greater the reluctance.
“Come ON boss, what’s the point of moving just 5 meters?”

When building effective Scrum teams, however, there is no alternative.
Just get the
team together. Even if you have to personally threaten each individual, carry all their
gear, and wipe up their old coffee stains. If there is no space for the team, make
space. Somewhere. Even if you have to place the team in the basement. Move tables
around, bribe the office manager, do whatever it takes. Just get the team together.

Once you have the team together the payoff will be immediate. After just one sprint the
team will agree that it was a good idea to move together (speaking from personal
experience that is, there’s nothing saying your team won’t be too stubborn to admit
it).

Now what does “together” mean? How should the desks be laid out?
Well, I don’t have any
strong opinion on the optimal desk layout. And even if I did, I assume most teams don’t
have the luxury of being able to decide exactly how to layout their desks. There are
usually physical constraints – the neighboring team, the toilet door, the big slot
machine in the middle of the room, whatever.

“Together” means:
* Audibility: Anybody in the team can talk to anybody else without shouting or leaving
his desk.
* Visibility: Everybody in the team can see everybody else.
Everyone can see
the taskboard. Not necessarily close enough to be able to read it, but at least see it.
* Isolation: If your whole team were to suddenly stand up and engage in a spontaneous and
lively design discussion, there is nobody outside the team close enough to be disturbed.
And vice versa.

“Isolation” doesn’t mean that the team has to be completely isolated. In a cubicle
environment it may be enough that your team has its own cubicle and big enough cubicle
walls to filter out most of the noise from non-team elements.

And what if you have a distributed team? Well then you are out of luck.
Use as many
technical aids as you can to minimize the damage – video conferencing, webcams, desktop
sharing tools, etc.

Keep the product owner at bay
-----------------------------
The product owner should be near enough so that the team
can wander over and ask him something, and so that he can wander over to the taskboard.
But he should not be seated with the team. Why? Because chances are he will not be able
to stop himself from meddling in details, and the team will not “gel” properly (i.e.
reach a tight, self-managed, hyperproductive state).

To be honest, this is speculation. I haven’t actually seen a case where the product
owner is sitting with the team, so I have no actual empirical reason to say that it is a
bad idea. Just gut feeling and hearsay from other Scrum masters.
Keep the managers and coaches at bay This is a bit hard for me to write about, since I
was both manager and coach...
It was my job to work as closely with the teams as possible. I set up the teams, moved
between them, pair programmed with people, coached Scrum masters, organized sprint
planning meetings, etc. In retrospect most people thought this was a Good Thing, since I
had some experience with agile software development.

But, then, I was also (enter Darth Vader music) the chief of development, a functional
manager role. Which means by entering a team it would automatically become less
self-managing. “Heck, boss is here, he probably has lots of opinions on what we should
be doing and who should be doing what. I’ll let him do the talking.”

My point is this; If you are Scrum coach (and perhaps also a manager), do get involved
as closely as possible. But only for a limited period, then get out and let the team gel
and self-manage. Check up on the team once in a while (not too often) by attending
sprint demos and looking at the taskboard and listening in on morning scrums. If you see
an improvement area, take the Scrum master aside and coach him. Not in front of the
team.
Another good idea is to attend sprint retrospectives (see pg 67 “How we do sprint
retrospectives”), if your team trusts you enough not to let your presence clam them
up.

As for well-functioning Scrum teams, make sure they get everything they need, then stay
the hell out of the way (except during sprint demos).

8 How we do daily scrums
========================
Our daily scrums are pretty much by
the book. They start exactly on time, every day at the same place. In the beginning we
would go to a separate room to do sprint planning (those were the days when we used
electronic sprint backlogs), however now we do daily scrums in the team room right
in front of the taskboard. Nothing can beat that.

We normally do the meetings standing up, since that reduces the risk of surpassing 15
minutes.

How we update the taskboard
---------------------------
We normally update the taskboard during the daily scrum. As
each person describes what he did yesterday and will do today, he pulls post-its around
on the taskboard. As he describes an unplanned item, he puts up a post-it for that. As
he update his time estimates, he writes the new time estimate on the post-it and crosses
off the old one. Sometimes the Scrum master does the post-it stuff while people talk.

<figure>

Some teams have a policy that each person should update the taskboard before each
meeting. That works fine as well. Just decide on a policy and stick to it.
Regardless
of what format your sprint backlog is in, try to get the whole team involved in keeping
the sprint backlog up-to-date. We’ve tried doing sprints where the Scrum master is the
sole maintainer of the sprint backlog and has to go around every day and ask people
about their remaining time estimates. The disadvantages of this are:
* The Scrum master
spends too much time administrating stuff, instead of supporting the team and removing
impediments.
* Team members are unaware of the status of the sprint, since the sprint backlog is not
something they need to care about. This lack of feedback reduces the overall agility and
focus of the team.

If the sprint backlog is well-designed it should be just as easy for each team member to
update it himself.

Immediately after the daily scrum meeting, someone sums up all the time estimates
(ignoring those in the “done” column of course) and plots a new point on the sprint
burndown.

Dealing with latecomers
-----------------------
Some teams have a can of coins and bills. When you are late,
even if only one minute late, you add a fixed amount to the can. No questions asked. If
you call before the meeting and say you’ll be late you still have to pay up.

You only get off the hook if you have a good excuse such as a doctor’s appointment or
your own wedding or something.

The money in the can is used for social events. To buy hamburgers when we have gaming
nights for example :o)

This works well. But it is only necessary for teams where people often come late. Some
teams don’t need this type of scheme.

Dealing with “I don’t know what to do today”
--------------------------------------------
It is not uncommon for somebody to say
“Yesterday I did bla bla bla, but today I haven’t the foggiest clue of what to do” (hey
that last bit rhymed).
Now what?

Let’s say Joe and Lisa are the ones who don’t know what to do today.

If I am Scrum master I just move on and let the next guy talk, but make note of which
people didn’t have anything to do. After everybody’s had their say, I go through the
taskboard with the whole team, from top to bottom, and check that everything is in sync,
that everybody knows what each item means, etc. I invite people to add more post-its.
Then I go back to those people who didn’t know what to do “now that we’ve gone through
the taskboard, do you have any ideas about what you can do today”? Hopefully they will.

If not, I consider if there is any pair-programming opportunity here. Let’s say Niklas
is going to implement the back office user admin GUI today.
In that case I politely
suggest that perhaps Joe or Lisa could pair program with Niklas on that. That usually
works.

And if that doesn’t work, here’s the next trick.

Scrum master: “OK, who wants to demonstrate the beta-ready release to us?” (assuming that was the
sprint goal)
Team: confused silence
Scrum master: “Aren’t we done?”
Team: “um... no”
Scrum master: “Oh darn. Why not? What’s left to do?”
Team: “Well we don’t even have a test server to run
it on, and the build script is broken.”
Scrum master: “Aha.” (adds two post-its to the task wall).  “Joe and Lisa, how can you help us today?”
Joe: “Um.... I guess I’ll try to find some test server somewhere”.
Lisa: “... and I’ll try to fix that build script”.

If you are lucky, someone will actually demonstrate the beta-ready release you asked for.
Great! You have achieved your sprint goal. But what if you are in mid-sprint? Easy.
Congratulate the team on a job well done, grab one or two of the stories from the “next”
section at the bottom right of your taskboard, and move them to the “not checked out” column
to the left. Then redo the daily scrum. Notify the product owner that you have added some
items to the sprint.

But what if the team has not yet achieved the print goal and Joe and Lisa still refuse to come
up with something useful to do. I usually consider one of the following strategies (none of
them are very nice, but then this is a last resort):

* Shame: “Well if you have no idea how you can help the team, I suggest you go home, or read a
book or something. Or just sit around until someone calls for your help.”.
* Old-school: Simply assign them a task.
* Peer pressure: Say “feel free to take your time Joe and Lisa,
we’ll all just stand here and take it easy until you come up with something to do that will
help us reach the goal.”
* Servitude: Say “Well you can help the team indirectly by being
butlers today. Fetch coffee, give people massage, clean up some trash, cook us some lunch,
and whatever else we may ask for
during the day.” You may be surprised by how fast Joe and Lisa manage to come up with useful
technical tasks :o)

If one person frequently forces you to go that far, then you should probably take that
person aside and do some serious coaching. If the problem still remains, you need to
evaluate whether this person is important to your team or not.

If he isn’t too important, try to get him removed from your team.

If he is important, then try to pair him up with somebody else who can act as his
“shepherd”. Joe might be a great developer and architect, just that he really prefers other
people to tell him what to do. Fine. Give Niklas the duty of being Joe’s permanent shepherd.
Or take on the duty yourself. If Joe is important enough to your team it will be worth the
effort. We’ve had cases like this and it more or less worked.

9 How we do sprint demos
========================
The sprint demo (or sprint review as
some people call it) is an important part of Scrum that people tend to underestimate.

“Oh do we really have to do a demo? There really isn’t much fun to show!”
“We don’t have time to prepare a &%$# demo!”
“I don’t have time to attend other team’s demos!”

Why we insist that all sprints end with a demo
----------------------------------------------
A well executed sprint demo, although it may
seem undramatic, has a profound effect.
* The team gets credit for their accomplishment. They feel good.
* Other people learn what your team is doing.
* The demo attracts vital feedback
from stakeholders.
* Demos are (or should be) a social event where different teams can
interact with each other and discuss their work. This is valuable.
* Doing a demo forces the
team to actually finish stuff and release it (even if it is only to a test environment).
Without demos, we kept getting huge piles of 9% finished stuff. With demos we may get fewer
items done, but those items are really done, which is (in our case) a lot better than having
a whole pile of stuff that is just sort of done and will pollute the next sprint.

If a team is more or less forced to do a sprint demo, even when they don’t have much that
really works, the demo will be embarrassing. The team will stutter and stumble while doing
the demo and the applause afterwards will be half-hearted. People will feel a bit sorry for
the team, some may be irritated that they wasted time going to a lousy demo.

This hurts. But the effect is like a bitter-tasting medicine. Next sprint, the team will
really try to get stuff done! They will feel that “well, maybe we can only demonstrate 2
things next sprint instead of 5, but dammit this time it’s going to WORK!”. The team knows
that they will have to do a demo no matter what, which significantly increases the chance
that there
will be something useful to demonstrate. I’ve seen this happen several times.

Checklist for sprint demos
--------------------------
* Make sure you clearly present the sprint goal. If there are people at the demo who don’t
know anything about your product, take a few minutes to describe the product.
* Don’t spend
too much time preparing the demo, especially not on flashy presentations. Cut the crap out
and just focus on demonstrating actual working code.
* Keep a high pace, i.e. focus your
preparations on making the demo fast-paced rather than beautiful.
* Keep the demo on a
business-oriented level, leave out the technical details. Focus on “what did we do” rather
than “how did we do it”.
* If possible, let the audience try the product for themselves.
* Don’t demonstrate a bunch of minor bug fixes and trivial features. Mention them but don’t
demo them, since that generally takes too long and detracts focus from the more important
stories.

Dealing with “undemonstratable” stuff
-------------------------------------
Team member: “I’m not going to demonstrate this item,
because it can’t be demonstrated. The story is ‘Improve scalability so system can handle
10,000 simultaneous users’. I can’t bloody well invite 10,000 simultaneous users to the demo
can I?”
Scrum master: “Are you done with the item?”
Team member. “Yes, of course”.
Scrum master: “How do you know?”
Team member: “I set the system up in a performance test
environment, started 8 load servers and pestered the system with simultaneous requests”.
Scrum master: “But do you have any indication that the system will handle 10,000 users”.
Team member: “Yes. The test machines are crappy, yet they could handle 50,000 simultaneous
requests during my test”.
Scrum master: “How do you know?”
Team member (frustrated): “Well
I have this report! You can see for yourself, it shows how the test was set up and how many
requests were sent!”
Scrum master: “Oh excellent! Then there’s your “demo”. Just show the
report and go through it with the audience. Better than nothing right?”.
Team member: “Oh, is that enough? But its ugly, need to polish it up.”.
Scrum master: “OK, but don’t spend too long. It doesn’t have to be pretty, just informative.”

10 How we do sprint retrospectives
==================================

Why we insist that all teams do retrospectives
----------------------------------------------

The most important thing about retrospectives
is to make sure they happen.

For some reason, teams don’t always seem inclined to do retrospectives.
Without gentle
prodding most of our teams would often skip the retrospective and move on to the next sprint
instead. It may be a cultural thing in Sweden, not sure.

Yet, everybody seems to agree that retrospectives are extremely useful. In fact, I’d say the
retrospective is the second most important event in Scrum (the first being the sprint
planning meeting) because this is your best chance to improve!

Of course, you don’t need a retrospective meeting to come up with good ideas, you can do
that in your bathtub at home! But will the team accept your idea? Maybe, but the likelihood
of getting buy-in from the team is very much higher if the idea comes “from the team”, i.e.
comes up during the retrospective when everyone is allowed to contribute and discuss the
ideas.

Without retrospectives you will find that the team keeps making the same mistakes over and
over again.

How we organize retrospectives
------------------------------
The general format varies a bit, but usually we do it
something like this:
* We allocate 1 – 3 hours depending on how much discussion is anticipated.
* Participants: The product owner, the whole team, and myself.
* We move off to a closed room, a cozy sofa corner, the rooftop patio, or some place like
that. As long as we can have undisturbed discussion.
* We usually don’t do retrospectives in the team room, since people’s attentions will tend to wander.
* Somebody is designated as secretary.
* The Scrum master shows the sprint backlog and, with help from the team,
summarizes the sprint. Important events and decisions, etc.
* We do “the rounds”. Each person
gets a chance to say, without being interrupted, what they thought was good, what they think
could have been better, and what they would like to do differently next sprint.
* We look at
the estimated vs. actual velocity. If there is a big difference we try to analyze why.
* When time is almost up the Scrum master tries to summarize concrete suggestions about what we can
do better next sprint.

Our retrospectives are generally not too structured. The underlying theme is always the same
though: “what can we do better next sprint”.

Here is a whiteboard example from a recent retrospective:

<figure>

Three columns:
* Good: If we could redo the same sprint again, we would do these things the
same way.
* Could have done better: If we could redo the same sprint again, we would do these
things differently.
* Improvements: Concrete ideas about how we could improve in the future.

So column 1 and 2 look into the past, while column 3 looks into the future.

After the team brainstormed up all these post-its, they used “dot voting” to determine which
improvements to focus on during next sprint. Each team member was given 3 magnets and
invited to vote on whatever improvements they would like the team to prioritize during next
sprint.
Each team member could distribute the magnets as they like, even placing all three
on a single issue.

Based on this they selected 5 process improvements to focus on, and will follow this up
during next retrospective.

It is important not too get overambitious here. Focus on just a few improvements per sprint.

Spreading lessons learned between teams
---------------------------------------
The information that comes up during a sprint
retrospective is usually extremely valuable. Is this team having a hard time focusing
because the sales manager keeps kidnapping programmers to participate as “tech experts” in
sales meetings? This is important information. Perhaps other teams are having the same
problem? Should we be educating the product management more about our products, so they can
do the sales support themselves?

A sprint retrospective is not only about how this one team can do a better job during next
sprint, it has wider implications than that.

Our strategy for handling that is very simple. One person (in this case me) attends all sprint
retrospectives and acts as the knowledge bridge. Quite informal.

An alternative would be to have each Scrum team publish a sprint retrospective report. We have tried
that but found that not many people read such reports, and even fewer act upon them. So we do it the
simple way instead.

Important rules for the “knowledge bridge” person:
* He should be a good listener.
* If the
retrospective is too silent, he should be prepared to ask simple but well-aimed questions that
stimulate discussion within
the group. For example “if you could rewind time and redo this same sprint from day 1, what would
you do differently?”.
* He should be willing to spend time visiting all retrospectives for all teams.
* He should be in some kind of position of authority, so he can act upon improvement suggestions that
are outside the team’s control.

This works fairly well but there may be other approaches that work
a whole lot better. In that case please enlighten me.

To change or not to change
--------------------------
Let’s say the team concludes that “we communicated too little within the
team, so we kept stepping on each other’s toes and messing up each other’s designs.”

What should you do about it? Introduce daily design meetings? Introduce new tools to ease
communication? Add more wiki pages? Well, maybe.
But then again, maybe not.

We’ve found that, in many cases, just identifying a problem clearly is enough for it to solve itself
automatically next sprint. Especially if you post the sprint retrospective on the wall in the team
room (which we always forget to do, shame on us!). Every change you introduce has some kind of cost
so, before introducing changes, consider doing nothing at all and hoping that the problem will
disappear (or become smaller) automatically.

The example above (“we communicated too little within the team...”) is a typical example of
something that may be best solved by doing nothing at all.

If you introduce a new change every time someone complains about something, people may become
reluctant to reveal minor problem areas, which would be terrible.

Examples of things that may come up during retrospectives
Here are some examples of typical things
that come up during sprint planning, and typical actions.

                    “We should have spent more time breaking down stories into sub items and tasks”
This is quite
common. Every day at the daily scrum, team members find themselves saying “I don’t really know
what to do today”. So after each daily scrum you spend time finding concrete tasks. Usually more
effective to do that upfront.

Typical actions: none. The team will probably sort this out themselves during next sprint
planning. If this happens repeatedly, increase the sprint planning time-box.

                                                                  “Too many external disturbances”
Typical actions:
* ask the team to reduce their focus factor next
sprint, so that they have a more realistic plan * ask the team to record disturbances better next
sprint. Who disturbed, how long it took. Will make it easier to solve the problem later.
* ask the team to try to funnel all disturbances to the scrum master or product owner
* ask the team to
designate one person as “goalkeeper”, all disturbances are routed to him, so that the rest of the
team can focus. Could be the Scrum master or a rotating position.
                                            “We overcommitted and only got half of the stuff done”
Typical actions: none. The team will
probably not overcommit next sprint. Or at least not overcommit as badly.

                                                    “Our office environment is too noisy and messy”
Typical actions:
* try to create a better
environment, or move the team offsite. Rent a hotel room. Whatever. See pg 55 “How we arrange the
team room’).
* If not possible, tell the team to decrease their focus factor next sprint, and to
clearly state that this is because of the noisy and messy environment. Hopefully this will cause
the product owner to start pestering upper management about this.

Fortunately I’ve never had to threaten to move the team offsite. But I will if I have to :o)

11 Slack time between sprints
=============================
In real life, you can’t always sprint. You need to
rest between sprints. If you always sprint, you are in effect just jogging.

The same in Scrum and software development in general. Sprints are quite intensive. As a developer
you never really get to slack off, every day you have to stand at that danged meeting and tell
everyone what you accomplished yesterday. Few will be inclined to say “I spent most of the day
with my feet on the table browsing blogs and sipping cappuccino”.

In addition to the actual rest itself, there is another good reason to have some slack between
sprints. After the sprint demo and retrospective, both the team and the product owner will be full
of information and ideas to digest. If they immediately run off and start planning the next
sprint, chances are nobody will have had a chance to digest any information or lessons learned,
the product owner will not have had time to adjust his priorities after the sprint demo, etc.

Bad:

<figure>

We try to introduce some kind of slack before starting a new sprint (more specifically, the period
after the sprint retrospective and before the next sprint planning meeting). We don’t always
succeed though.

At the very least, we try to make sure that the sprint retrospective and the subsequent sprint
planning meeting don’t occur on the same day.
Everybody should at least have a good night’s
sprintless sleep before starting a new sprint.

Better:

<figure>

Even better:

<figure>

One way to do this is “lab days” (or whatever you choose to call them).
That is, days where
developers are allowed to do essentially whatever they want (OK, I admit, inspired by Google). For
example read up on the latest tools and APIs, study for a certification, discuss nerdy stuff with
colleagues, code a hobby project, etc.

Our goal is to have a lab day between each sprint. That way you get a natural rest between
sprints, and you will have a dev team that gets a realistic chance to keep their knowledge
up-to-date. Plus it’s a pretty attractive employment benefit.
Best?

<figure>

Currently we have lab days once per month. The first Friday every month to be specific. Why not
between sprints instead? Well, because I felt it was important that the whole company takes the
lab day at the same time.
Otherwise people tend to not take it seriously. And since we (so far)
don’t have aligned sprints across all products, I had to select a sprint- independent lab day
interval instead.

We might some day try to synchronize the sprints across all products (i.e.
same sprint start and
end date for all products and teams). In that case we will definitely place a lab day between
each sprint.

12 How we do release planning and fixed price contracts
=======================================================
Sometimes we need to plan ahead more than one
sprint at a time.
Typically in conjunction with a fixed price contract where we have to plan
ahead, or else risk signing something that we can’t deliver on time.

Typically, release planning for us is an attempt to answer the question “when, at latest, will we
be able to deliver version 1.0 of this new system”.

If you really want to learn about release planning I suggest you skip this chapter and instead buy
Mike Cohn’s book “Agile Estimating and Planning”. I really wish I had read that book earlier (I
read it after we had figured this stuff out on our own...). My version of release planning is
a bit simplistic but should serve as a good starting point.

Define your acceptance thresholds
---------------------------------

In addition to the usual product backlog, the product owner
defines a list of acceptance thresholds which is a simple classification of what the importance
levels in the product backlog actually mean in terms of the contract.

Here’s an example of acceptance threshold rules:
* All items with importance >= 100 must be included in version 1.0, or else we’ll be fined to death.
* All items with importance 50 - 9 should be
included in version 1.0, but we might be able to get away with doing them in a quick follow-up
release.
* Items with importance 25 - 4 are required, but can be done in a follow-up release 1.1.
* Items with importance < 25 are speculative and might never be needed at all.

And here’s an example of a product backlog, color-coded based on the above rules.

<figure>

Red = must be included in version 1.0 (banana – pear)
Yellow = should be included in version 1.0 (raisin – onion)
Green = may be done later (grapefruit – peach)

So if we deliver everything from banana to onion by the deadline we’re safe. If time runs short we
might get away with skipping raisin, peanut, donut or onion. Everything below onion is bonus.

Time estimate the most important items
--------------------------------------
In order to do release planning the product owner needs
estimates, at least for all stories that are included in the contract. Just like when sprint
planning, this is cooperative effort between the product owner and the team – the team estimates,
the product owner describes the items and answers questions.

A time estimate is valuable if it turns out to be close to correct, less valuable if it turns out
to be off by, say, a factor 30%, and completely worthless if it doesn’t have any connection to
reality.

Here’s my take on the value of a time estimate in relation to who calculates it and how long time
they spend doing it.

<figure>

All that was just a long-winded way of saying:
* Let the team do the estimates.
* Don’t make them spend too much time.
* Make sure they understand that the time estimates are crude estimates, not commitments.

Usually the product owner gathers the whole team in a room, provides some refreshments, and tells
them that the goal of this meeting is to time- estimate the top 20 (or whatever) stories in the
product backlog. He goes through each story once, and then lets the team get to work. The product
owner stays in the room to answer questions and clarify the scope for each item as necessary. Just
like when doing sprint planning, the “how to demo” field is a very useful way to lessen the risk
of misunderstanding.

This meeting must be strictly time-boxed, otherwise teams tend to spend too much time estimating
too few stories.
If the product owner wants more time spent on this he simply schedules another
meeting later. The team must make sure that the impact of these meetings on their current sprints
is clearly visible to the product owner, so that he understands that their time-estimating work
doesn’t come for free.

Here is an example of how the time estimates might end up (in story points):

<figure>

Estimate velocity
-----------------
OK, so now we have some kind of crude time estimate for the most important
stories.
Next step is to estimate our average velocity per sprint.

This means we need to decide on our focus factor. See pg 24 "How does the team decide which
stories to include in the sprint".

Focus factor is basically “how much of the team’s time is spent focusing on there currently
committed stories”. It is never 100% since teams lose time doing unplanned items, doing context
switches, helping other teams, checking their email, fixing their broken computer, arguing
politics in the kitchen, etc.

Let’s say we determine focus factor for the team to be 50% (quite low, we normally hover around
70%). And let’s say our sprint length will be 3 weeks (15 days) long and our team size is 6.

Each sprint is thus 0 man-days long, but can only be expected to produce complete 45 man-days
worth of stories (due to the 50% focus factor).

So our estimated velocity is 45 story points.

If each story had a time estimate of 5 days (which they don’t) then this team would crank out
approximately
stories per sprint.

Put it together into a release plan
-----------------------------------
Now that we have time estimates and a velocity (45) we can easily chop the product backlog into sprints:

<figure>

Each sprint includes as many stories as possible without exceeding the estimated velocity of 45.

Now we can see that we’ll probably need 3 sprints to finish all the “must haves” and “should haves”.

3 sprints = calendar weeks = 2 calendar months. Now is that the deadline we promise
the customer? Depends entirely on the nature of the contract; how fixed the scope is etc. We
usually add a significant buffer to protect against bad time estimates, unexpected problems,
unexpected features, etc. So in this case we might agree to set the delivery date to 3 months in
the future, giving us 1 month “reserve”.

The nice thing is that we can demonstrate something
usable to the customer every 3 weeks and invite him to change the requirements as we go along
(depending of course on how the contract looks).

Adapting the release plan
-------------------------
Reality will not adapt itself to a plan, so it must be the other way
around.

After each sprint we look at the actual velocity for that sprint. If the actual velocity was
very different from the estimated velocity, we revise the estimated velocity for future sprints
and update the release plan. If this puts us into trouble, the product owner may start
negotiating with the customer or start checking how he can reduce scope without breaking the
contract. Or perhaps he and the team comes up with some way to increase velocity or increase
focus factor by removing some serious impediment that was identified during the sprint.

The product owner might call the customer and say “hi, we’re running a bit behind schedule but I
believe we can make the deadline if we just remove the “embedded Pacman” feature that takes a
lot of time to build.
We can add it in the follow-up release 3 weeks after the first release if
you like”.

Not good news to the customer perhaps, but at least we are being honest and giving the customer
an early choice – should we deliver the most important stuff on time or deliver everything late.
Usually not a hard choice :o)

13 How we combine Scrum with XP
===============================
To say that Scrum and XP (eXtreme Programming) can be fruitfully
combined is not really a controversial statement. Most of the stuff I see on the net supports
that hypothesis, so I won’t spend time arguing why.

Well, I will mention one thing. Scrum focuses on management and organization practices while XP
focuses mostly on actual programming practices. That’s why they work well together – they
address different areas and complement each other.

I hereby add my voice to the existing empirical evidence that Scrum and XP can be fruitfully
combined!

I’m going to highlight some of the more valuable XP practices and how they apply to our
day-to-day work. Not all our teams have managed to adopt all practices, but in total we’ve
experimented with most aspects of the XP/Scrum combination. Some XP practices are directly
addressed by Scrum and can be seen as overlapping, for example “Whole Team”, “Sit Together”,
“Stories”, and “Planning game”. In those cases we’ve simply stuck to Scrum.

Pair programming
----------------
We started doing this lately in one of our teams. Works quite well actually.
Most of our other teams still don’t pair program very much but, having actually tried it in one
team for a few sprints now, I’m inspired to try to coach more teams into giving it a shot.

Some conclusions so far about pair programming:
* Pair programming does improve code quality.
* Pair programming does improve team focus (for example when the guy behind you says “hey is that
stuff really necessary for this sprint?”).
* Surprisingly many developers that are strongly against pair programming actually haven’t tried
it, and quickly learn to like it once they do try it.
* Pair programming is exhaustive and should
not be done all day.
* Shifting pairs frequently is good.
* Pair programming does improve
knowledge spread within the group. Surprisingly fast too.
* Some people just aren’t comfortable
with pair programming.
Don’t throw out an excellent programmer just because he isn’t
comfortable with pair programming.
* Code review is an OK alternative to pair programming.
* The
“navigator” (the guy not using the keyboard) should have a computer of his own as well. Not for
development, but for doing little spikes when necessary, browsing documentation when the
“driver” (the guy at the keyboard) gets stuck, etc.
* Don’t force pair programming upon people.
Encourage people and provide the right tools but let them experiment with it at their own pace.

Test-driven development (TDD)
-----------------------------
Amen! This, to me, is more important than both Scrum and XP. You can
take my house and my TV and my dog, but don’t try to stop me from doing TDD! If you don’t like TDD
then don’t let me in the building, because I will try to sneak it in one way or another :o)

Here’s a 10 second summary of TDD:

    Test-driven development means that you write an automated test, then you write just enough
    code to make that one test pass, then you refactor the code primarily to improve readability
    and remove duplication. Rinse and repeat.

Some reflections on test-driven development.

* TDD is hard. It takes a while for a programmer
to get it. In fact, in many cases it doesn’t really matter how much you teach and coach and
demonstrate – in many cases the only way for a programmer to get it is to have him pair
program with somebody else who is good at TDD. Once a programmer does get it, however, he will
usually be severely infected and will never want to work in any other way.
* TDD has a profoundly positive effect on system design.
* It takes time to get TDD up and running effectively in a new product, especially black-box
integration tests, but the return on investment is fast.
* Make sure you invest the time
necessary to make it easy to write tests. This means getting the right tools, educating
people, providing the right utility classes or base classes, etc.

We use the following tools for test-driven development:
* jUnit / httpUnit / jWebUnit. We are considering TestNG and Selenium.
* HSQLDB as an embedded in-memory DB for testing purposes.
* Jetty as an embedded in-memory web container for testing purposes.
* Cobertura for test coverage metrics.
* Spring framework for wiring up different types of test fixtures (with
mocks, without mocks, with external database, with in- memory database, etc).

In our most sophisticated products (from a TDD perspective) we have automated black-box
acceptance tests. These tests start up the whole system in memory, including databases and
webservers, and access the system using only its public interfaces (for example HTTP).

This makes for extremely fast develop-build-test cycles. This also acts as a safety net,
giving the developers confidence enough to refactor often, which means the design stays clean
and simple even as the system grows.

TDD on new code
---------------
We do TDD for all new development, even if that means initial project setup
takes longer (since we need more tools and support for test harnesses etc). That’s a bit of a
no-brainer, the benefits are so great that there really is no excuse not to do TDD.

TDD on old code
---------------
TDD is hard, but trying to do TDD on a code base that wasn’t built using TDD
from start... that’s really hard! Why? Well, actually, I could write many pages on this topic
so I think I’ll stop here. I’ll save that for my next paper “TDD from the Trenches” :o)

We spent quite a lot of time trying to automate integration testing in one of our more complex
systems, a code base that had been around for a while and was in a severely messed up state
and completely devoid of tests.

For every release of the system we had a team of dedicated testers who would perform a whole
bunch of complex regression and performance tests. The regression tests were mostly manual
work. This significantly slowed down our development and release cycle. Our goal was to
automate these tests. After banging our heads against the wall for a few months, however, we
hadn’t really gotten that much closer.

After that we switched approach. We conceded to the fact that we were stuck with manual
regression testing, and instead starting asking ourselves “How can we make the manual testing
process less time consuming?” This was a gaming system, and we realized that a lot of the test
team’s time was spent doing quite trivial setup tasks, such as browsing around in the back
office to set up tournaments for testing purposes, or waiting around for a scheduled
tournament to start. So we created utilities for that.
Small, easily accessible shortcuts and
scripts that did all the grunt work and let the testers focus on the actual testing.

That effort really paid off! In fact, that is probably what we should have done from start. We
were too eager to automate the testing that we forgot to do it step-by-step, where the first
step was to build stuff that makes manual testing more efficient.

Lesson learned: If you are stuck with having to do manual regression testing, and want to
automate this away, don’t (unless it is really easy).
Instead, build stuff that makes manual
regression testing easier. Then consider automating the actual testing.

Incremental design
------------------
This means keeping the design simple from start and continuously improving
it, rather than trying to get it all right from the start and then freezing it.

We’re doing fairly well at this, i.e. we spend a reasonable amount of time refactoring and
improving existing design, and we rarely spend time doing big up-front designs. Sometimes we
screw up of course, for example by allowing a shaky design to “dig in” too strongly so that
refactoring becomes a big project. But all in all we’re fairly satisfied.

Continuous design improvement is mostly an automatic side effect of doing TDD

Continuous integration
----------------------
Most of our products have a fairly sophisticated continuous integration

setup based on Maven and QuickBuild. This is extremely valuable and
HOW WE COMBINE SCRUM WITH XP | 85
time-saving. It is the ultimate solution to the good ol’ “hey but it works on my machine”
issue. Our continuous build server acts as the “judge” or reference point from which to
determine the health of all our codebases.
Every time someone checks something in to the
version control system the continuous build server will wake up, build everything from scratch
on a shared server, and run all the tests. If anything goes wrong it will send an email
notifying the entire team that the build failed, including info about exactly which code
change broke the build, link to test reports, etc.

Every night the continuous build server will rebuild the product from scratch and publish
binaries (ears, wars, etc), documentation, test reports, test coverage reports, dependency
reports, etc, to our internal documentation portal. Some products will also be automatically
deployed to a test environment.

Setting this up was a lot of work, but worth every minute.

Collective code ownership
-------------------------
We encourage collective code ownership but not all teams have
adopted this yet. We’ve found that pair programming with frequent rotation of pairs
automatically leads to a high level of collective code ownership.
Teams with a high level of
collective code ownership have proven to be very robust, for example their sprint doesn’t die
just because some key person is sick.

Informative workspace
---------------------
All teams have access to whiteboards and empty wall space and make quite
good use of this. In most rooms you’ll find the walls plastered with all kinds of information
about the product and project. The biggest problem is old junk accumulating on the walls, we
might introduce a “housekeeper” role in each team.

We encourage the use of taskboards, but not all teams have adopted this yet. See pg 55 “How we
arrange the team room.”

Coding standard
---------------
Lately we’ve started defining a coding standard. Very useful, wish we had done
it earlier. It takes almost no time at all, just start simple and let it grow. Only write down
stuff that isn’t obvious to everyone and link to existing material whenever possible.

Most programmers have their own distinct coding style. Little details like how they handle
exceptions, how they comment code, when they return
null, etc. In some cases the difference doesn’t matter, in other cases it can lead to a
severely inconsistent system design and hard-to-read code. A code standard is very useful
here, as long as you focus on the stuff that matters.

Here are some examples from our code standard:
* You may break any of these rules, but make sure there is a good reason and document it.
* Use the Sun code conventions by default:
http://java.sun.com/docs/codeconv/html/CodeConvTOC.doc.html
* Never, ever, ever catch exceptions
without logging the stack trace or rethrowing. log.debug() is fine, just don’t lose that stack
trace.
* Use setter-based dependency injection to decouple classes from each other (except of
course when tight coupling is desirable).
* Avoid abbreviations. Well-known abbreviations
such as DAO are fine.
* Methods that return Collections or arrays should not return null.
Return empty collections and arrays instead of null.

Sustainable pace / energized work
---------------------------------
Many books on agile software development claim that extended
overtime is counterproductive in software development.

After some unwilling experimentation on this I can only agree wholeheartedly!

About a year ago one of our teams (the biggest team) was working insane amounts of overtime.
The quality of the existing code base was dismal and they had to spend most of their time
firefighting. The test team (which was also doing overtime) didn’t have a chance to do any
serious quality assurance. Our users were angry and the tabloids were eating us alive.

After a few months we had managed to lower people’s work hours to decent levels. People worked
normal hours (except during project crunches sometimes). And, surprise, productivity and
quality improved noticeably.

Of course, reducing the work hours was by no means the only aspect that led to the
improvement, but we’re all convinced it had a large part in it.

14 How we do testing
====================
This is the hardest part. I’m not sure if
it’s the hardest part of Scrum, or just the hardest part of software development in general.

Testing is the part that probably will vary most between different organizations. Depending on
how many testers you have, how much test automization you have, what type of system you have
(just server+webapp? or do you actually ship boxed software?), size of release cycles, how
critical the software is (blog server vs. flight control system), etc.

We’ve experimented quite a lot with how to do testing in Scrum. I’ll try to describe what
we’ve been doing and what we’ve learnt so far.

You probably can’t get rid of the acceptance test phase
-------------------------------------------------------
In the ideal Scrum world, a sprint
results in a potentially deployable version of your system. So just deploy it, right?

<figure>

Wrong.

Our experience is that this usually doesn’t work. There will be nasty bugs.
If quality has
any sort of value to you, some kind of manual acceptance testing phase is required. That’s
when dedicated testers that are not part of the team hammer the system with those types of
tests that the Scrum team couldn’t think of, or didn’t have time to do, or didn’t have the
hardware to
do. The testers access the system in exactly the same way as the end users, which means they
must be done manually (assuming your system is for human users).

<figure>

The test team will find bugs, the Scrum team will have to do bug-fix releases, and sooner or
later (hopefully sooner) you will be able to release a bug-fixed version 1.0.1 to the end
users, rather than the shaky version 1.0.0.

When I say “acceptance test phase” I am referring to the whole period of testing, debugging,
and re-releasing until there is a version good enough for production release.

Minimize the acceptance test phase
----------------------------------
The acceptance test phase hurts. It feels distinctly
un-agile. Although we can’t get rid of it, we can (and do) try to minimize it. More
specifically, minimize the amount of time needed for the acceptance test phase. This is done
by:
* Maximizing the quality of the code delivered from the Scrum team
* Maximizing the efficiency
of the manual test work (i.e. find the best testers, give them the best tools, make sure they
report time- wasting tasks that could be automated)

So how do we maximize the quality of
the code delivered from the Scrum team? Well, there are lots of ways. Here are two that we
find work very well:
* Put testers in the Scrum team
* Do less per sprint

Increase quality by putting testers in the Scrum team
-----------------------------------------------------

<figure>

Yes, I hear both objections:
* “But that’s obvious! Scrum teams are supposed to be cross functional!”
* “Scrum teams are supposed to be role-less! We can’t have a guy who is only a tester!”

Let me clarify. What I mean by “tester” in this case is “A guy whose primary skill is
testing”, rather than “a guy whose role is to do only testing”.

Developers are often quite lousy testers. Especially developers testing their own code.

                                                                    The tester is the “signoff guy”
In addition to being “just” a team member, the tester has an important job.
He is the signoff guy. Nothing is considered “done” in a sprint until he says
it’s done. I’ve found that developers often say something is done when it really isn’t. Even
if you have a very clear definition of “done” (which you really should, see pg 32 “Definition
of “done””), developers will frequently forget it. We programmers are impatient people and
want to move on to the next item ASAP.

So how does Mr. T (our tester) know something is done then? Well, first of all, he should
(surprise) test it! In many cases it turns out that something a developer considered to be
“done” wasn’t even possible to test! Because it wasn’t checked in, or wasn’t deployed to the
test server, or couldn’t be started, or whatever. Once Mr. T has tested the feature, he should
go through the “done” checklist (if you have one) with the developer. For example if the
definition of “done” mandates that there should be a release note, then Mr. T checks that
there is a release note. If
there is some kind of more formal specification for this feature (rare in our case) then Mr. T
checks up on that as well. Etc.

A nice side effect of this is that the team now has a guy who is perfectly suited to organize
the sprint demo.

What does the tester do when there is nothing to test?
------------------------------------------------------

This question keeps coming up. Mr. T:
“Hey Scrum master, there’s nothing to test at the moment, so what should I do?”. It may take a
week before the team completes the first story, so what should the tester do during that time?

Well, first of all, he should be preparing for tests. That is, writing test specs, preparing a
test environment, etc. So when a developer has something that is ready to test, there should
be no waiting, Mr. T should dive right in and start testing.

If the team is doing TDD then people spend time writing test code from day 1. The tester
should pair-program with developers that are writing test code. If the tester can’t program at
all he should still pair-program with developers, except that he should only navigate and let
the developer do the typing. A good tester usually comes up with different types of tests than
a good developer does, so they complement each other.
If the team is not doing TDD, or if
there isn’t enough test-case writing to fill up the tester’s time, he should simply do
whatever he can to help the team achieve the sprint goal. Just like any other team member. If
the tester can program then that’s great. If not, your team will have to identify all
non-programming tasks that need to be done in the sprint.

When breaking down stories into tasks during the sprint planning meeting, the team tends to
focus on programming tasks. However usually there are lots of non-programming tasks that need
to be done in the sprint.
If you spend time trying to identify the non-programming tasks
during the sprint planning phase, chances are Mr. T will be able to contribute quite a lot,
even if he can’t program and there is no testing to do right now.

Examples of non-programming tasks that often need to be done in a sprint:
* Set up a test environment.
* Clarify requirements.
* Discuss deployment details with operations.
* Write deployment documents (release notes, RFC, or whatever your organization does).
* Contact with external resources (GUI designers for example).
* Improve build scripts.
* Further breakdown of stories into tasks.
* Identify key questions from the developers and get them answered.

On the converse side, what do we do if Mr. T becomes a bottleneck? Let’s say we are on the
last day of the sprint and suddenly lots of stuff is done and Mr. T doesn’t have a chance to
test everything. What do we do? Well we could make everybody in the team into Mr. T’s
assistants. He decides which stuff he needs to do himself, and delegates grunt testing to the
rest of the team. That’s what cross functional teams are all about!

So yes, Mr. T does have a special role in the team, but he is still allowed to do other work,
and other team members are still allowed to do his work.

Increase quality by doing less per sprint
-----------------------------------------
This goes back to the sprint planning meeting.
Simply put, don’t cram too many stories items into the sprint! If you have quality problems,
or long acceptance test cycles, do less per sprint! This will almost automatically lead to
higher quality, shorter acceptance test cycles, fewer bugs affecting end users, and higher
productivity in the long run since the team can focus on new stuff all the time rather than
fixing old stuff that keeps breaking.

It is almost always cheaper to build less, but build it stable, rather than to build lots of
stuff and then have to do panic hot-fixes.

Should acceptance testing be part of the sprint?
------------------------------------------------
We waver a lot here. Some of our teams
include acceptance testing in the sprint. Most of our teams however don’t, for two reasons:
* A sprint is time-boxed. Acceptance testing (using my definition which includes debugging and
re-releasing) is very difficult to time-box. What if time runs out and you still have a
critical bug?
Are you going to release to production with a critical bug? Are you going to
wait until next sprint? In most cases both solutions are unacceptable. So we leave manual
acceptance testing outside.
* If you have multiple Scrum teams working on the same product, the
manual acceptance testing must be done on the combined result of both team’s work. If both
teams did manual acceptance within the sprint, you would still need a team to test the final
release, which is the integrated build of both team’s work.

<figure>

This is by no means a perfect solution but good enough for us in most cases.

Sprint cycles vs. acceptance test cycles
----------------------------------------
In a perfect McScrum world you don’t need acceptance
test phases since each Scrum team releases a new production-ready version of your system after
each sprint.

<figure>

Well, here’s a more realistic picture:

<figure>

After sprint 1, a buggy version 1.0.0 is released. During sprint 2, bug reports start pouring
in and the team spends most of its time debugging and is forced to do a mid-sprint bug-fix
release 1.0.1. Then at the end of sprint 2 they release a new feature-version 1.1.0, which of
course is even buggier since they had even less time to get it right this time due to all the
disturbances from last release. Etc etc.

The diagonal red lines in sprint 2 symbolize chaos.

Not too pretty eh? Well, the sad thing is that the problem remains even if you have an
acceptance test team. The only difference is that most of the bug reports will come from the
test team instead of from angry end users.
That’s a huge difference from a business
perspective, but for developers it amounts to almost the same thing. Except that testers are
usually less aggressive than end users. Usually.

<figure>

We haven’t found any simple solution to this problem. We’ve experimented a lot with different
models though.

First of all, again, maximize the quality of the code that the Scrum team releases. The cost
of finding and fixing bugs early, within a sprint, is just so extremely low compared to the
cost of finding and fixing bugs afterwards.

But the fact remains, even if we can minimize the number of bugs, there will still be bug
reports coming after a sprint is complete. How do we deal with that?

Approach 1: “Don’t start building new stuff until the old stuff is in production”
---------------------------------------------------------------------------------
Sounds nice doesn’t it? Did you also get that warm fuzzy feeling?

We’ve been close to adopting this approach several times, and drawn fancy models of how we
would do this. However we always changed our minds when we realized the downside. We would
have to add a non time- boxed release period between sprints, where we do only testing and
debugging until we can make a production release.

<figure>

We didn’t like the notion of having non time-boxed release periods between sprints, mainly
because it would break the regular sprint heartbeat. We could no longer say that “every 3 weeks
we start a new sprint”. Besides, this
doesn’t completely solve the problem. Even if we have a release period, there will be urgent
bug reports coming in from time to time, and we have to be prepared to deal with them.

Approach 2: “OK to start building new stuff, but prioritize getting the old stuff into production”
--------------------------------------------------------------------------------------------------
This is our preferred approach. Right now at least.

Basically, when we finish a sprint we move on to the next one. But we expect to be spending
some time in the next sprint fixing bugs from the last sprint. If the next sprint gets
severely damaged because we had to spend so much time fixing bugs from the previous sprint, we
evaluate why this happened and how we can improve quality. We make sure sprints are long
enough to survive a fair amount of bug fixing from the previous sprint.

Gradually, over a period of many months, the amount of time spent fixing bugs from previous
sprints decreased. In addition we were able to get fewer people involved when bugs did happen,
so that the whole team didn’t need to get disturbed each time. Now we are at a more acceptable
level.

<figure>

During sprint planning meetings we set the focus factor low enough to account for the time we
expect to spend fixing bugs from last sprint. With time, the teams have gotten quite good at
estimating this. The velocity metric helps a lot (see pg. 24 “How does the team decide which
stories to include in the sprint?”).

Bad approach – “focus on building new stuff”
--------------------------------------------
This in effect means “focus on building new stuff
rather than getting old stuff into production”. Who would want to do that? Yet we made this
mistake quite often in the beginning, and I’m sure many other companies do as well. It’s a
stress-related sickness. Many managers don’t really understand that, when all the coding is
finished, you are usually still far
from production release. At least for complex systems. So the manager (or product owner) asks
the team to continue adding new stuff while the backpack of old almost-ready-to-release code
gets heavier and heavier, slowing everything down.

Don’t outrun the slowest link in your chain
-------------------------------------------
Let’s say acceptance test is your slowest link.
You have too few testers, or the acceptance test period takes long because of the dismal code
quality.

Let’s say your acceptance test team can test at most 3 features per week (no, we don’t use
“features per week” as a metric; I’m using it just for this example). And let’s say your
developers can develop 6 new features per week.

It will be tempting for the managers or product owners (or maybe even the team) to schedule
development of 6 new features per week.

Don’t! Reality will catch up to you one way or another, and it will hurt.

Instead, schedule 3 new features per week and spend the rest of the time alleviating the
testing bottleneck. For example:
* Have a few developers work as testers instead (oh they will
love you for that...).
* Implement tools and scripts that make testing easier.
* Add more automated test code.
* Increase sprint length and have acceptance test included in sprint.
* Define some sprints as “test sprints” where the whole team works as an acceptance test team.
* Hire more testers (even if that means removing developers)

We’ve tried all of these solutions (except the last one). The best long term solution is of course
point 2 and 3, i.e. better tools and scripts and test automation.

Retrospectives are a good forum for identifying the slowest link in the chain.

Back to reality
---------------
I’ve probably given you the impression that we have testers in all Scrum teams, that
we have a huge acceptance test teams for each product, that we release after each sprint, etc, etc.

Well, we don’t.

We’ve sometimes managed to do this stuff, and we’ve seen the positive effects of it. But we are
still far from an acceptable quality assurance process, and we still have a lot to learn there.

15 How we handle multiple Scrum teams
=====================================
A lot of things get much harder when you
have multiple Scrum teams working on the same product. That problem is universal and doesn’t really
have anything to do with Scrum. More developers = more complications.

We have (as usual) experimented with this. At most we had a team of approximately 40 people working
on the same product.

The key questions are:
* How many teams to create
* How to allocate people into teams

How many teams to create
------------------------
If dealing with multiple Scrum teams is so hard, why do we bother? Why not
just put everyone in the same team?

The biggest single Scrum team we’ve had was around 11 people. It worked, but not too well. Daily
scrums tended to drag on past 15 minutes.
Team members didn’t know what other team members were
doing, so there would be confusion. It was difficult for the Scrum master to keep everyone aligned
towards the goal, and difficult to find time to address all obstacles that were reported.

The alternative is to split into two teams. But is that better? Not necessarily.

If the team is experienced and comfortable with Scrum, and there is a logical way of splitting the
roadmap into two distinct tracks, and those two tracks don’t both involve the same source code, then
I’d say it’s a good idea to split the team. Otherwise I’d consider sticking to one team, despite the
disadvantage of big teams.

My experience is that it is better to have fewer teams that are too big than to have many small
teams that keep interfering with each other. Make small teams only when they don’t need to
interfere with each other!

Virtual teams
-------------
How do you know if you made the right or wrong decision with respect to the “big
team” vs. “many teams” tradeoff?

If you keep your eyes and ears open you may notice that “virtual teams” form.

Example 1: You choose to have one large team. But when you start looking at who talks to whom
during the sprint, you notice that the team has effectively split into two sub-teams.

<figure>

Example 2: You choose to have three smaller teams. But when you start looking at who talks to
whom during the sprint, you notice that team 1 and team 2 are talking to each other all the
time, while team 3 is working in isolation.

<figure>

So what does that mean? That your team division strategy was wrong?
Yes, if the virtual teams
seem to be sort of permanent. No, if the virtual teams seem to be temporary.

Look at example 1 again. If the two virtual sub-teams tend to change once in a while (i.e.
people move between the virtual sub-teams) then you probably made the right decision to
have them as a single Scrum team. If the two virtual sub-teams stay the same throughout the
whole sprint, you probably want to break them apart into two real Scrum teams next sprint.

Now look at example 2 again. If team 1 and team 2 are talking to each (and not team 3)
throughout the whole sprint, you probably want to combine team 1 and team 2 into a single Scrum team
next sprint. If team 1 and team 2 are talking to each other a lot throughout the first half of the
sprint, and then team 1 and team 3 talk to each other throughout the second half of the sprint, then
you should consider combining all three teams into one, or just leaving them as three teams. Bring
up the question during the sprint retrospective and let the teams decide for themselves.

Team division is one of the really hard parts of Scrum. Don’t think too deeply or optimize too
hard. Experiment, keep watch for virtual teams, and make sure you take plenty of time to
discuss this type of stuff during your retrospectives. Sooner or later you will find the right
solution for your particular situation. The important thing is that the teams are comfortable
and don’t stumble over each other too often.

Optimal team size
-----------------
Most books I’ve read claim that the “optimal” team size is somewhere around 5–9 people.
From what I’ve seen so far I can only agree. Although I’d say 3 – 8 people. In fact, I believe
it is worth taking some pains to achieve teams of that size.

Let’s say you have a single Scrum team of 10 people. Consider ejecting the two weakest team
members. Oops, did I just say that?

Let’s say you have two different products, with one 3-person team per product, and both are
moving too slow. It might be a good idea to combine them into one single 6-person team
responsible for both products. In that case let one of the two product owners go (or give him
an advisory role or something).

<figure>

Let’s say you have a single 12-person Scrum team, because the code base is in such a crappy
state that there is no way for 2 different teams to work on it independently. Put some serious
effort into fixing the code base (instead of building new features) until you get to a point
where you can split the team. This investment will probably pay off quite quickly.

Synchronized sprints – or not?
------------------------------
Let’s say you have three Scrum teams working on the same
product.
Should their sprints be synchronized, i.e. start and end together? Or should they
overlap?

Our first approach was to have overlapping sprints (with respect to time).

<figure>

This sounded nice. At any given moment in time there would be an ongoing sprint just about to
end and a new sprint just about to begin. The product owner’s workload would be evenly spread
out over time. There would be releases flowing continuously out of the system. Demos every
week. Hallelujah.

Yeah, I know, but it really did sound convincing at the time!

We had just started doing this when I one day had the opportunity to talk to Ken Schwaber (in
conjunction with my Scrum certification). He pointed out that this was a bad idea, that it
would be much better to
synchronize the sprints. I don’t remember his exact reasons, but after some discussion I was
convinced.

<figure>

This is the solution we’ve used ever since, and never regretted it. I’ll never know if the
overlapping sprints strategy would have failed, but I think so. The advantage of synchronized
sprints is:
* There is a natural time at which to rearrange teams – between sprints! With
overlapping sprints, there is no way to rearrange teams without disturbing at least one team in
mid-sprint.
* All teams could work towards the same goal in a sprint and do sprint planning
meetings together, which leads to better collaboration between teams.
* Less administrative overhead, i.e. fewer sprint planning meetings, sprint demos, and releases.
Why we introduced a “team lead” role
------------------------------------
Let’s say we have a single product with three teams.

<figure>

The red guy labeled P is Product Owner. The black guys labeled S are Scrum Masters. The rest
are grunts... er... respectable team members.

With this constellation, who decides which people should be in which teams? The product owner?
The three Scrum masters together? Or does every person get to select his own team? But then
what if everyone wants to be in team 1 (because Scrum master 1 is so good looking)?

What if it later turns out that it is really not possible to have more than two teams working
in parallel on this code base, so we need to transform this into two -person teams instead of
three 6-person teams. That means 2 Scrum masters. So which one of the current 3 Scrum masters
will be relieved of his title?

In many companies these will be quite sensitive issues.

It is tempting to let the product owner do the allocation and reassignment of people. But that
isn’t really product owner stuff right? The product owner is the domain expert who tells the
team in which direction they should run. He should not really have to get involved in the nitty
gritty details. Especially since he is a “chicken” (if you’ve heard the chicken and pig
metaphor, otherwise google up “chickens and pigs”).

We’ve solved this by introducing a “team lead” role. This corresponds to what you might call
“Scrum of Scrums master” or “the boss” or “main Scrum master” etc. He doesn’t have to lead any
single team, but he is responsible for cross-team issues such as who should be Scrum master for
teams, how people should be divided into teams, etc.

We had a hard time coming up with a good name for this role. “Team lead” was the least lousy
name we could find.

This solution has worked well for us and I can recommend it (regardless of what you decide to
call the role).

How we allocate people to teams
-------------------------------
There are two general strategies for allocating people to
teams, when you have multiple teams on the same product.
* Let a designated person do the allocation, for example the “team lead” that I mentioned
above, the product owner, or the functional manager (if he is involved enough to be able to
make good decisions here).
* Let the teams do it themselves somehow.

We’ve experimented with all three. Three? Yeah. Strategy 1, Strategy 2, and a combination of both.

We found that the combination of both works best.

Before the sprint planning meeting, the team lead calls for a team allocation meeting together
with the product owner and all Scrum masters. We talk about last sprint and decide if any team
reallocations are warranted. Perhaps
we want to combine two teams, or move some people from one team to another. We decide on
something and write it down as a proposed team allocation, which we bring to the sprint
planning meeting.

The first thing we do during the sprint planning meeting is go through the top-priority items
in the product backlog. The team lead then say something like:

“Hi everyone. We suggest the following team allocation for next sprint.”

<figure>

“As you see, this would mean a reduction from 4 to 3 teams. We have listed members for each
team. Please group up and grab yourself a wall section.”

(team lead waits while people wander around in the room, after a while there are 3 groups of
people, each standing next to an empty wall section).

“Now this team division is preliminary! It is just a starting point, to save time. As the
sprint planning meeting progresses you are free to wander off to another team instead, split
your team into two, combine with another team, or whatever. Use common sense based on the
product owner’s priorities.”

This is what we have found works best. A certain level of centralized control initially,
followed by a certain level of decentralized optimization afterwards.

Specialized teams – or not?
---------------------------
Let’s say your technology consists of three main components:

<figure>

And let’s say you have 15 people working on this product, so you really don’t want to run them
as a single Scrum team. What teams do you create?

Approach 1: component-specialized teams
---------------------------------------
One approach is to create component-specialized teams
such as a “client team”, a “server team”, and a “DB team”.

<figure>

This is where we started. Doesn’t work too well, at least not when most stories involve
multiple components.

For example let’s say we have a story named “notice-board where users can post messages to each
other”. This notice board feature would involve updating the user interface in the client,
adding logic to the server, and adding some tables in the database.

<figure>

This means all three teams - the client team, the server team, and the DB team - have to
collaborate to get this story done. Not too good.

Approach 2: cross-component teams
---------------------------------
A second approach is to create cross-component teams, i.e.
teams that are not tied to any specific component.

<figure>

If many of your stories involve multiple components this team type division strategy will work
better. Each team can implement a whole story including the client parts, server parts, and DB
parts. The teams can thereby work more independently of each other, which is a Good Thing.

One of the first things we did when introducing Scrum was to break up the existing
component-specialized teams (approach 1) and create cross- component teams instead (approach
2). This lessened the number of cases of “we can’t complete this item because we are
waiting for the server guys to do their part.”

We do, however, sometimes assemble temporary component-specialized teams when there is a strong
need.

Rearrange teams between sprints - or not?
-----------------------------------------
Each sprint is usually quite different from the
other, depending on which types of stories that are top priority at that particular moment. As
a result, the optimal team setup may be different for each sprint.

In fact, almost every sprint we found ourselves saying something like “this sprint isn’t really
a normal sprint because (bla bla bla)....”. After a while we just gave up the notion of
“normal” sprints. There are no normal sprints. Just like there are no “normal” families or
“normal” people.

One sprint it may be a good idea to have a client-only team, consisting of everyone who knows
the client code base well. Next sprint it may be a good idea to have two cross-component teams
and split the client people between them.

One of the key aspects of Scrum is “team gel”, i.e. if a team gets to work together over
multiple sprints they will usually become very tight. They will learn to achieve group flow and
reach an incredible productivity level. But it takes a few sprints to get there. If you keep
changing the teams around you will never achieve really strong team gel.

So if you do want to rearrange the teams, make sure you consider the consequences. Is this a
long term change or a short term change? If it is a short term change considering skipping it.
If it is a long term change, go for it.

One exception is when you start doing Scrum with a large team for the first time. In this case
it is probably worth experimenting a bit with team subdivision until you find something that
everyone is comfortable with.  Make sure everybody
understands that it is OK to get it all wrong the first few times, as long as you keep improving.

Part-time team members
----------------------
I can only confirm what the Scrum books say – having part-time members
of a Scrum team is generally not a good idea.

Let’s say you are about to take on Joe as a part-time member of your Scrum team. Think
carefully first. Do you really need Joe on your team?
Are you sure you can’t get Joe
full-time? What are his other commitments? Can someone else take over Joe’s other commitment
and let Joe taken on a more passive, supportive role with respect to that commitment? Can Joe
join your team full time from next sprint, and in the mean time transfer his other
responsibilities to someone else?

Sometimes there is just no way out. You desperately need Joe because he is the only DBA in the
building, but the others teams need him just as badly so he will never be allocated fulltime to
your team, and the company can’t hire more DBAs. Fine. That’s a valid case for having him on a
part-time basis (which by the way is exactly what happened to us).
But make sure you really do
this evaluation every time.

In general I’d rather have a team of 3 full-timers than 8 part-timers.

If you have one person that will divide his time among multiple teams, like the aforementioned
DBA, it is a good idea to still have him primarily assigned to one team. Figure out which team
is likely to need him the most, and make that his “home team”. When nobody else is dragging him
off, he will attend that team’s daily scrums, sprint planning meetings, retrospectives, etc.

How we do Scrum-of-Scrums
-------------------------
Scrum-of-scrums is basically a regular meeting where all Scrum
masters gather up to talk.

At one point in time we had four products, where three of the products only had one Scrum team
each, and the last product had 25 people divided into several Scrum teams. Something like this:

<figure>

This means we had two levels of Scrum-of-Scrums. We had one “product level” Scrum-of-Scrums
consisting of all teams within Product D, and one “corporate level” Scrum-of-Scrums consisting
of all products.

Product level Scrum-of-Scrums
-----------------------------
This meeting was very important. We did it once per week,
sometimes more often than that. We discussed integration issues, team balancing issues,
preparations for next sprint planning meeting, etc. We allocated 30 minutes but frequently
overran. An alternative would have been to have Scrum-of-Scrums every day but we never got
around to trying that.

Our Scrum-of-Scrums agenda was
1) Round the table, everyone describes what their team
accomplished last week, what they plan to accomplish this week, and what impediments they have.
2) Any other cross-team concerns that need to be brought up, for example integration issues.

The agenda for Scrum-of-Scrums is not really important to me, the important thing is that you
have regular Scrum-of-Scrums meetings.

Corporate level Scrum-of-Scrums
-------------------------------
We called this meeting ”The Pulse”. We’ve done this meeting in
a variety of formats, with a variety of participants. Lately we’ve ditched the whole concept
and replaced it with a weekly all-hands (well, all people involved in development) meeting
instead. 15 minutes.  What? 15 minutes? All-hands? All members of all teams of all products?
Does that work?

Yes it works if you (or whoever runs the meeting) are strict about keeping it short.

The meeting format is:
1) News and updates from the chief of development. Info about upcoming events for example.
2) Round-robin. One person from each product group reports on what they
accomplished last week, what they plan to accomplish this week, and any problems. Some other
people report as well (CM lead, QA lead, etc).
3) Anybody else is free to add any info or ask questions

This is a forum for brief information, not discussion or reflection. By leaving it at that, 15
minutes usually works. Sometimes we overrun, but very rarely to more than 30 minutes total. If
interesting discussions pop up I pause them and invite those who are interested to stay after
the meeting and continue the discussion.

Why do we do an all-hands pulse meeting? Because we noticed that the corporate-level Scrum of
Scrums was mostly about reporting. We rarely had actual discussions in that group. In addition,
many other people outside the group were hungry for this type of info. Basically, teams want to
know what others teams are doing. So we figured that if we are going to meet and spend time
informing each other about what each team is doing, why not just let everyone attend.

Interleaving the daily scrums
-----------------------------
If you have many Scrum teams within a single product, and they
all do the daily scrum at the same time, you have a problem. The product owner (and nosy people
like me) can only attend one team’s daily scrum per day.

So we ask teams to avoid having daily scrums at the same time.

<figure>

The sample schedule above is from the period when we had daily scrums in separate rooms, rather
than in the team room. The meetings are normally 15 minutes but each team gets a 30-minute slot
in the room in case they need to overrun slightly.

This is extremely useful for two reasons.
1. People like the product owner and myself can visit all daily scrums on a single morning.
There’s no better way to get an accurate picture of how the sprint is coming along, and what
the key threats are.
2. Teams can visit each other’s daily scrums. Doesn’t happen too often,
but once in a while two teams will be working on a similar area, so a few members drop in on
each other’s daily scrums to stay in sync.

The downside is less freedom for the team – they can’t choose any time they like for the daily
scrum. This hasn’t really been a problem for us though.

Firefighting teams
------------------
We had a situation where a large product was unable to adopt Scrum because
they spent too much time firefighting, i.e. panic-fixing bugs on their prematurely released
system. This was a real vicious cycle, they were so busy firefighting that they didn’t have
time to work proactively to prevent fires (i.e. improve the design, automating tests, create
monitoring tools, alarm tools, etc).

We addressed this problem by creating a designated firefighting team, and a designated Scrum
team.

The Scrum team’s job was to (with the product owner’s blessing) try to stabilize the system
and, effectively, prevent fires.
The firefighting team (we called them “support” actually) had two jobs.
1) Fight fires
2) Protect the Scrum team from all kinds of disturbances, including
things such as fending off ad-hoc feature requests coming in from nowhere.

The firefighting team was placed nearest the door; the Scrum team was placed in the back of the
room. So the firefighting team could actually physically protect the Scrum team from
disturbances such as eager salespeople or angry customers.

Senior developers were placed on both teams, so that one team wouldn’t be too dependent on core
competence from the other.

This was basically an attempt to solve a Scrum bootstrapping problem.
How can we start doing
Scrum if the team doesn’t have a chance to plan their work more than one day at a time? Our
strategy was, as mentioned, to split the group.

This worked pretty well. Since the Scrum team was given room to work proactively they were
finally able to stabilize the system. In the meantime the firefighting team completely gave up
the notion of being able to plan ahead, they worked completely reactively, just fixing whatever
panic issue would come up next.

Of course, the Scrum team was not completely undisturbed. Frequently the firefighting team had
to involve key people from the Scrum team, or at worst the whole team.

Anyway, after a couple of months the system was stable enough that we could ditch the
firefighting team and create additional Scrum teams instead. The firefighters were quite happy
to park their battered helmets and join Scrum teams instead.

Splitting the product backlog – or not?
---------------------------------------
Let’s say you have one product and two Scrum teams.
How many product backlogs should you have? How many product owners? We’ve evaluated three
models for this. The choice has a pretty big effect on how sprint planning meetings are carried
out.

Strategy 1: One product owner, one backlog
------------------------------------------
This is the “There Can Only Be One” model. Our preferred model.

The good thing about this model is that you can let teams pretty much form themselves based on
the product owner’s current top priorities. The product owner can focus on what he needs, and
let the teams decide how to split the work up.

<figure>

To be more concrete, here’s how the sprint planning meeting works for this team:

The sprint planning meeting takes place at an external conference center.

Just before the meeting, the product owner declares one wall to be the “product backlog wall”
and puts up stories up there (index cards), ordered by relative priority. He keeps putting them
up until that wall is full, which is usually more than enough items for a sprint.

<figure>

Each Scrum team selects an empty wall section for themselves and posts their team name there.
That’s their “team wall”. Each team then grab stories from the product backlog wall, starting
from the top priority stories, and pulls the index cards to their own team wall.

This is illustrated in the picture below, with yellow arrows symbolizing the flow of story
index cards from the product backlog wall to the team walls.

<figure>

As the meeting progresses, the product owner and the teams haggle over the index cards, moving
them around between teams, moving them up and down to change priority, breaking them down into
smaller items, etc.
After an hour or so, each team has a first candidate version of a sprint
backlog on their team wall. After that the teams work independently, time estimating and
breaking down to tasks.

<figure>

It’s messy and chaotic and exhausting, but also effective and fun and social. When time is up,
all teams usually have enough information to start their sprint.

Strategy 2: One product owner, multiple backlogs
------------------------------------------------
In this strategy, the product owner maintains
multiple product backlogs, one per team. We haven’t actually tried this approach, but we’ve
been close. This is basically our fallback plan in case the first approach fails.

The weakness of this strategy is that the product owner is allocating stories to teams, a task
that teams probably are better at doing themselves.

<figure>

Strategy 3: Multiple product owners, one backlog per owner
This is like the second strategy, one product backlog per team, but with one product owner per team as well!

<figure>

We haven’t done this, and we probably never will.

If the two product backlogs involve the same code base, this will probably cause serious
conflicts of interest between the two product owners.

If the two product backlogs involve separate codebases, this is essentially the same as
splitting the whole product into separate sub-products and running them independently. This
means we are back to the one-team-per- product situation, which is nice and easy.

Code branching
--------------
With multiple teams working on the same code base we inevitably have to deal
with code branches in the SCM (software configuration management) system. There are lots of
books and articles on how to deal with multiple people working on the same code base so I won’t
get into detail here. I don’t have anything new or revolutionary to add. I will, however,
summarize some of the most important lessons learned so far by our teams.
* Be strict about keeping the mainline (or trunk) in a consistent state. This means, at the very
least, that everything should compile and all unit tests should pass. It should be possible to
create a working release at any given moment. Preferably the
continuous build system should build and auto-deploy to a test environment every night.
* Tag each release. Whenever you release to acceptance test or to production, make sure there is a
version tag on your mainline identifying exactly what was released. That means you can, at any
time in the future, go back and create a maintenance branch from that point.
* Create new branches only when necessary. A good rule of thumb is to branch off a new codeline only when
you can’t use an existing codeline without breaking that codeline’s policy. When in doubt,
don’t branch. Why? Because each active branch costs in administration and complexity.
* Use branches primarily to separate different lifecycles. You may or may not decide to have each
Scrum team code on their own codeline. But if you mix short-term fixes with long term changes
on the same codeline, you will find it very difficult to release the short-term fixes!
* Synchronize often. If you are working on a branch, synchronize to mainline whenever you have
something that builds. Every day when you get to work, synchronize from mainline to your
branch, so that your branch is up-to-date with respect to other teams’ changes. If this gives
you merge-hell just accept the fact that it would have been even worse to wait.

Multi-team retrospectives
-------------------------
How do we do sprint retrospectives when there are multiple teams
working on the same product?

Immediately after the sprint demo, after the applause and the mingle, each team goes off to a
room of their own, or to some comfortable out-of-office location. They do their retrospectives
pretty much as I described on pg 67 "How we do Sprint retrospectives".

During the sprint planning meeting (which all teams attend, since we do synchronized sprints
within each product), the first thing we do is let one spokesman from each team stand up
and summarize the key points from their retrospective. Takes about 5 minutes per team. Then we
have open discussion for about 10 – 20 minutes. Then we take a break. Then we start the actual
sprint planning.

We haven’t tried any other way for multiple teams, this works good enough. The biggest
disadvantage is that there is no slack time after the sprint retrospective part, before the
sprint planning part of the meeting.  (See pg 73 "Slack time between sprints" )

For single-team products, we don’t do any retrospective summary during the sprint planning
meeting. No need to, since everybody was present at the actual retrospective meeting.

16 How we handle geographically distributed teams
=================================================
What happens when team members are in different
geographic locations?
Much of the Scrum and XP “magic” is based on co-located tightly
collaborating team members that pair program and meet face-to-face every day.

We have some geographically separated teams, and we also have team members working from home
from time to time.

Our strategy for this is quite simple. We use every trick we can come up with to maximize the
communication bandwidth between the physically separated team members. I don’t only mean
communication bandwidth as in Mbit/second (although that is of course important as well). I
mean communication bandwidth in a wider sense:

* The ability to pair program together.
* The ability to meet face-to-face at the daily scrum.
* The ability to have face-to-face discussions at any time.
* The ability to meet physically and
socialize.
* The ability to have spontaneous meetings with the whole team.
* The ability to see
the same view of the sprint backlog, sprint burndown, product backlog, and other information
radiators.

Some of the measures we have implemented (or are implementing, we haven’t done them all yet)
are:
* Webcam and headset at each workstation.
* “Remote-enabled” conference rooms with webcams, conference microphones, always-on-always-ready
computers, desktop sharing software, etc.
* “Remote windows”. Big screens at each location, showing a permanent view of the other
locations. Sort of like a virtual window between two departments. You can stand there and
wave. You can see who is at his desk and who is talking to who.  This is to create a feeling of
“hey we’re in this together”.
* Exchange programs, where people from each location travel and visit each other on a regular basis.

Using these techniques and more we are slowly but surely starting to get the hang of how to do
sprint planning meetings, demos, retrospectives, daily scrums, etc, with team members
distributed geographically.

As usual it’s all about experimenting. Inspect => adapt => inspect => adapt => inspect => adapt
=> inspect => adapt => inspect => adapt

Offshoring
----------
We have several offshore teams and have been experimenting with how to handle this
efficiently using Scrum.

There are two main strategies here: separated teams or separated team members.

<figure>

The first strategy, separated teams, is a compelling choice. Nevertheless, we have started with
the second strategy, separated team members. There are several reasons for this.
1. We want the team members to get to know each other well.
2. We want excellent communication
infrastructure between the two locations, and want to give the teams a strong incentive to set
this up.
3. In the beginning, the offshore team is too small to form an effective scrum team
on their own.
4. We want a period of intense knowledge sharing before independent offshore
teams will be a feasible option.

In the long run we may well move towards the “separated teams” strategy.

Team members working from home
------------------------------
Working from home can be really good sometimes. Sometimes you
can get more programming done in one day at home than a whole week at work. At least if you
don’t have kids :o)

Yet one of the fundamentals in Scrum is that the whole team should be physically collocated. So
what do we do?

Basically we leave it to the teams to decide when and how often it is OK to work from home.
Some team members work from home regularly due to long commutes. We do, however, encourage the
teams to be physically collocated “most” of the time.

When team members work from home they join the daily scrum using a Skype voice call (sometimes
video). They are online through instant messaging all day. Not as good as being in the same
room, but good enough.

We once tried the concept of having Wednesdays designated as focus day.
That basically meant
"if you would like to work from home, that’s fine, but do it on Wednesdays. And check with your
team" This worked pretty well with the team that we tried it on. Usually most of the team
stayed home on Wednesdays and they get a lot done, while still collaborating fairly well. Since
it only was one day, the team members didn’t get too out-of-sync with each other. For some
reason this never quite caught on with the other teams though.

On the whole people working from home has not really been a problem for us.

17 Scrum master checklist
=========================
In this final chapter I will show you our scrum master “checklist”,
listing the most common administrative routines of our Scrum masters. Stuff that is easy to
forget. We skip the obvious things such as “remove impediments from the team”.

Beginning of sprint
-------------------
* After the Sprint planning meeting, create a Sprint info page.
  o Add a link to your page from the dashboard on the wiki.
  o Print the page and put it on the wall where people pass by your team.
* Send an email to everyone announcing that a new sprint is started. Include the sprint
goal and a link to the Sprint info page.
* Update the sprint statistics document. Add your
estimated velocity, team size, sprint length, etc.

Every day
---------
* Make sure the Daily Scrum meeting is started and ended on time.
* Make sure Stories are
added/removed from the Sprint backlog as necessary to keep the sprint on schedule.
  o Make sure the Product owner is notified of these changes.
* Make sure the Sprint backlog and burndown is kept up-to-date by the team.
* Make sure problems/impediments are solved or reported to Product owner and/or Chief of development.

End of sprint
-------------
* Do an open Sprint demo.
* Everyone should be notified about the demo a day or two before.
* Do a Sprint retrospective with the whole team and Product owner. Invite Chief of development as
well, so he can help spread the lessons learned.
* Update the sprint statistics document. Add
the actual velocity and key points from the retrospective.

18 Parting words
================
Whew! Never thought it would get this long.

Hope this paper gave you some useful ideas, whether you are new to Scrum or a seasoned veteran.

Since Scrum must be tailored specifically to each environment it is hard to argue
constructively over best practices at a general level. Nevertheless I’m interested in hearing
your feedback. Tell me how your approach differs from mine. Give me ideas on how to improve!

Feel free to contact me at henrik.kniberg@crisp.se.
I also keep an eye on scrumdevelopment@yahoogroups.com.

If you liked this book you might want to check in on my blog from time to time. I hope to be
adding some posts on Java and agile software development.
http://blog.crisp.se/henrikkniberg/

Oh, and don’t forget...
It’s just a job right?

Recommended reading Here are some books that have provided me with lots of inspiration and
ideas. Highly recommended!


About the author
================
Henrik Kniberg (henrik.kniberg@crisp.se) is a consultant at Crisp in Stockholm
(www.crisp.se), specializing in Java and Agile software development.

Ever since the first XP books and the agile manifesto appeared Henrik has embraced agile
principals and tried to learn how to apply them efficiently in different types of
organizations. As co-founder and CTO of Goyada 198-2003 he had ample opportunity to experiment
with test-driven development and other agile practices as a he built and managed a technical
platform and a 30-person development team.

In late 2005 Henrik was contracted as chief of development at a Swedish company in the gaming
business. The company was in a crisis situation with urgent organizational and technical
problems. Using Scrum and XP as a tool, Henrik helped the company out of the crisis by
implementing agile and lean principles at all levels in the company.

One Friday in November 2006 Henrik was home in bed with a fever and decided to jot down some
notes for himself about what he had learned over the past year. Once he started writing,
however, he couldn’t stop and after three days of frantic typing and drawing, the initial notes
had grown into an 80-page article entitled “Scrum and XP from the Trenches”, which ultimately
became this book.

Henrik takes a holistic approach and enjoys adopting different roles such as manager,
developer, scrummaster, teacher, and coach. He is passionate about helping companies build
excellent software and excellent teams, taking on whatever role is necessary.

Henrik grew up in Tokyo and now lives in Stockholm with his wife Sophia and two kids. He is an
active musician on his freetime, composing music and playing bass and keyboard with local
bands.
For more info see http://www.crisp.se/henrik.kniberg

